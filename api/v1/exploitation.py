"""
Exploitation API Endpoints

REST API endpoints for ethical exploitation and penetration testing operations.
All operations require proper authorization and are designed for defensive purposes.

Security Level: DEFENSIVE_ONLY - AUTHORIZED_TESTING_ONLY
"""

from datetime import datetime
from typing import Dict, Any, List, Optional, Union
from enum import Enum

from fastapi import APIRouter, HTTPException, Depends, Query, Path, Body, status
from pydantic import BaseModel, Field, validator

from ...modules import get_module
from ...modules.exploitation import (
    ExploitTarget, ExploitationType, ExploitSeverity, ExploitStatus, 
    ExploitResult, AuthorizationContext
)
from . import STANDARD_RESPONSES, APIResponseStatus

router = APIRouter()

# Pydantic models
class ExploitationTypeEnum(str, Enum):
    """Exploitation type enumeration"""
    CREDENTIAL_ATTACK = "credential_attack"
    BUFFER_OVERFLOW = "buffer_overflow"
    INJECTION_ATTACK = "injection_attack"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    NETWORK_ATTACK = "network_attack"
    WEB_EXPLOIT = "web_exploit"
    SOCIAL_ENGINEERING = "social_engineering"
    PHYSICAL_ACCESS = "physical_access"

class ExploitSeverityEnum(str, Enum):
    """Exploit severity enumeration"""
    LOW_IMPACT = "low_impact"
    MEDIUM_IMPACT = "medium_impact"
    HIGH_IMPACT = "high_impact"
    CRITICAL_IMPACT = "critical_impact"

class ExploitStatusEnum(str, Enum):
    """Exploit status enumeration"""
    NOT_ATTEMPTED = "not_attempted"
    IN_PROGRESS = "in_progress"
    SUCCESSFUL = "successful"
    FAILED = "failed"
    BLOCKED = "blocked"
    UNAUTHORIZED = "unauthorized"

class AuthorizationContextRequest(BaseModel):
    """Authorization context request model"""
    target_scope: List[str] = Field(..., description="Authorized target scope")
    authorized_by: str = Field(..., description="Authorization authority")
    duration_hours: int = Field(default=24, ge=1, le=168, description="Authorization duration in hours")
    restrictions: List[str] = Field(default_factory=list, description="Authorization restrictions")
    contact_info: str = Field("", description="Emergency contact information")

class ExploitTargetRequest(BaseModel):
    """Exploit target request model"""
    target: str = Field(..., description="Target for exploitation")
    target_type: str = Field(..., description="Type of target")
    vulnerability_id: str = Field(..., description="Vulnerability identifier")
    exploitation_type: ExploitationTypeEnum = Field(..., description="Type of exploitation")
    severity: ExploitSeverityEnum = Field(..., description="Expected impact severity")
    options: Dict[str, Any] = Field(default_factory=dict, description="Exploitation options")
    safety_checks: bool = Field(default=True, description="Enable safety checks")
    
    @validator('target')
    def validate_target(cls, v):
        if not v or len(v.strip()) == 0:
            raise ValueError('Target cannot be empty')
        return v.strip()

class ExploitResultResponse(BaseModel):
    """Exploit result response model"""
    target: str
    exploitation_type: ExploitationTypeEnum
    timestamp: datetime
    status: ExploitStatusEnum
    success: bool
    evidence: Dict[str, Any]
    impact_assessment: str
    remediation_steps: List[str]
    duration: float
    authorization_id: str
    metadata: Dict[str, Any] = {}

class ExploitOperationResponse(BaseModel):
    """Exploit operation response model"""
    status: APIResponseStatus
    operation_id: str
    target: str
    result: ExploitResultResponse
    metadata: Dict[str, Any] = {}

class ExploitStatusResponse(BaseModel):
    """Exploitation module status response"""
    module: str
    status: str
    version: str
    total_attempts: int
    successful_exploits: int
    active_authorizations: int
    audit_log_entries: int
    last_activity: Optional[str]
    security_disclaimer: str

# Dependency to get exploitation module
async def get_exploit_module():
    """Get exploitation module instance"""
    module = get_module("exploitation")
    if not module:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Exploitation module not available"
        )
    return module

# Endpoints
@router.get("/status", response_model=ExploitStatusResponse, responses=STANDARD_RESPONSES)
async def get_exploitation_status(module=Depends(get_exploit_module)):
    """Get exploitation module status and statistics"""
    try:
        status_info = await module.get_status()
        return ExploitStatusResponse(**status_info)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get status: {str(e)}"
        )

@router.post("/authorize", responses=STANDARD_RESPONSES)
async def create_authorization(
    auth_request: AuthorizationContextRequest,
    module=Depends(get_exploit_module)
):
    """Create authorization context for exploitation activities"""
    try:
        auth_context = module.create_authorization_context(
            target_scope=auth_request.target_scope,
            authorized_by=auth_request.authorized_by,
            duration_hours=auth_request.duration_hours
        )
        
        return {
            "authorization_id": auth_context.authorization_id,
            "target_scope": auth_context.target_scope,
            "authorized_by": auth_context.authorized_by,
            "start_time": auth_context.start_time.isoformat(),
            "end_time": auth_context.end_time.isoformat(),
            "emergency_stop_code": auth_context.emergency_stop_code,
            "message": "Authorization created successfully"
        }
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Authorization creation failed: {str(e)}"
        )

@router.post("/exploit", response_model=ExploitOperationResponse, responses=STANDARD_RESPONSES)
async def execute_exploit(
    exploit_request: ExploitTargetRequest,
    authorization_id: str = Query(..., description="Authorization ID for exploitation"),
    module=Depends(get_exploit_module)
):
    """Execute exploitation attempt against target"""
    try:
        # Get authorization context
        auth_context = module.auth_manager.active_authorizations.get(authorization_id)
        if not auth_context:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Invalid or expired authorization"
            )
        
        # Create exploit target
        exploit_target = ExploitTarget(
            target=exploit_request.target,
            target_type=exploit_request.target_type,
            vulnerability_id=exploit_request.vulnerability_id,
            exploitation_type=ExploitationType(exploit_request.exploitation_type.value),
            severity=ExploitSeverity(exploit_request.severity.value),
            authorization=auth_context,
            options=exploit_request.options,
            safety_checks=exploit_request.safety_checks
        )
        
        # Execute exploitation
        start_time = datetime.utcnow()
        exploit_result = await module.execute_exploit(exploit_target)
        
        # Convert result to response format
        result_response = ExploitResultResponse(
            target=exploit_result.target,
            exploitation_type=ExploitationTypeEnum(exploit_result.exploitation_type.value),
            timestamp=exploit_result.timestamp,
            status=ExploitStatusEnum(exploit_result.status.value),
            success=exploit_result.success,
            evidence=exploit_result.evidence,
            impact_assessment=exploit_result.impact_assessment,
            remediation_steps=exploit_result.remediation_steps,
            duration=exploit_result.duration.total_seconds(),
            authorization_id=exploit_result.authorization_id,
            metadata=exploit_result.metadata
        )
        
        return ExploitOperationResponse(
            status=APIResponseStatus.COMPLETED,
            operation_id=f"exploit_{int(start_time.timestamp())}",
            target=exploit_request.target,
            result=result_response,
            metadata={
                "exploitation_type": exploit_request.exploitation_type.value,
                "success": exploit_result.success,
                "authorization_id": authorization_id
            }
        )
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Exploitation failed: {str(e)}"
        )

@router.post("/emergency-stop", responses=STANDARD_RESPONSES)
async def emergency_stop(
    authorization_id: str = Query(..., description="Authorization ID"),
    stop_code: str = Query(..., description="Emergency stop code"),
    module=Depends(get_exploit_module)
):
    """Emergency stop for exploitation activities"""
    try:
        success = module.emergency_stop(stop_code, authorization_id)
        
        if success:
            return {"message": "Emergency stop executed successfully"}
        else:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid stop code or authorization ID"
            )
            
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Emergency stop failed: {str(e)}"
        )

@router.get("/results", response_model=List[ExploitResultResponse], responses=STANDARD_RESPONSES)
async def get_exploit_results(
    target: Optional[str] = Query(None, description="Filter by target"),
    exploitation_type: Optional[ExploitationTypeEnum] = Query(None, description="Filter by exploitation type"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum results to return"),
    module=Depends(get_exploit_module)
):
    """Get exploitation results with optional filtering"""
    try:
        # Get results from module
        exploitation_type_filter = ExploitationType(exploitation_type.value) if exploitation_type else None
        results = module.get_exploit_results(target=target, exploitation_type=exploitation_type_filter)
        
        # Limit results
        if limit:
            results = results[:limit]
        
        # Convert to response format
        result_responses = []
        for result in results:
            result_responses.append(ExploitResultResponse(
                target=result.target,
                exploitation_type=ExploitationTypeEnum(result.exploitation_type.value),
                timestamp=result.timestamp,
                status=ExploitStatusEnum(result.status.value),
                success=result.success,
                evidence=result.evidence,
                impact_assessment=result.impact_assessment,
                remediation_steps=result.remediation_steps,
                duration=result.duration.total_seconds(),
                authorization_id=result.authorization_id,
                metadata=result.metadata
            ))
        
        return result_responses
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get results: {str(e)}"
        )

@router.get("/audit-log", responses=STANDARD_RESPONSES)
async def get_audit_log(
    limit: int = Query(100, ge=1, le=1000, description="Maximum entries to return"),
    module=Depends(get_exploit_module)
):
    """Get exploitation audit log"""
    try:
        audit_log = module.get_audit_log()
        
        # Limit results
        if limit:
            audit_log = audit_log[-limit:]
        
        return {"audit_log": audit_log}
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get audit log: {str(e)}"
        )

@router.get("/techniques", responses=STANDARD_RESPONSES)
async def get_exploitation_techniques():
    """Get available exploitation techniques"""
    return {
        "techniques": [
            {
                "name": "credential_attack",
                "description": "Credential brute force and default credential testing",
                "risk_level": "medium",
                "authorization_required": True
            },
            {
                "name": "injection_attack",
                "description": "SQL injection and command injection testing",
                "risk_level": "high",
                "authorization_required": True
            },
            {
                "name": "network_attack",
                "description": "Network-based attack simulations",
                "risk_level": "medium",
                "authorization_required": True
            },
            {
                "name": "web_exploit",
                "description": "Web application exploit testing",
                "risk_level": "high",
                "authorization_required": True
            }
        ]
    }

@router.get("/disclaimer", responses=STANDARD_RESPONSES)
async def get_security_disclaimer():
    """Get security disclaimer and usage guidelines"""
    return {
        "disclaimer": """
        CRITICAL SECURITY NOTICE:
        
        This exploitation module is designed EXCLUSIVELY for authorized penetration testing
        and defensive security assessments. Use of these capabilities against systems
        without explicit written authorization is ILLEGAL and UNETHICAL.
        
        Users MUST:
        1. Obtain written authorization before using any exploitation techniques
        2. Comply with all applicable laws and regulations
        3. Use only for defensive security purposes
        4. Implement proper safeguards and logging
        5. Follow responsible disclosure practices
        
        UNAUTHORIZED USE IS STRICTLY PROHIBITED AND MAY RESULT IN LEGAL CONSEQUENCES.
        """,
        "requirements": [
            "Written authorization required for all operations",
            "Compliance with local and international laws",
            "Proper documentation and logging",
            "Emergency stop mechanisms",
            "Safety checks and validation"
        ],
        "contact": "security@aetherveil.com"
    }