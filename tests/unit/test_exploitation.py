"""
Unit tests for the Exploitation module.
"""
import pytest
import asyncio
from unittest.mock import Mock, patch, AsyncMock
from datetime import datetime, timedelta
import json
from typing import List, Dict, Any

from modules.exploitation import (
    ExploitationModule,
    ExploitEngine,
    AuthorizationManager,
    SafetyMonitor,
    ExploitTarget,
    ExploitResult,
    ExploitTechnique,
    ExploitCategory,
    RiskLevel,
    ExploitStatus,
    Authorization
)
from config.config import AetherVeilConfig


class TestExploitTarget:
    """Test ExploitTarget data class"""
    
    def test_exploit_target_creation(self):
        """Test ExploitTarget creation with default values"""
        target = ExploitTarget(
            target="192.168.1.1",
            technique=ExploitTechnique.SSH_BRUTEFORCE,
            category=ExploitCategory.CREDENTIAL_ATTACK
        )
        
        assert target.target == "192.168.1.1"
        assert target.technique == ExploitTechnique.SSH_BRUTEFORCE
        assert target.category == ExploitCategory.CREDENTIAL_ATTACK
        assert target.risk_level == RiskLevel.MEDIUM
        assert target.parameters == {}
        assert target.timeout == 300
        assert target.max_attempts == 3
    
    def test_exploit_target_with_custom_values(self):
        """Test ExploitTarget creation with custom values"""
        parameters = {"username": "admin", "password_list": ["admin", "password"]}
        target = ExploitTarget(
            target="ssh://192.168.1.1:22",
            technique=ExploitTechnique.SSH_BRUTEFORCE,
            category=ExploitCategory.CREDENTIAL_ATTACK,
            risk_level=RiskLevel.HIGH,
            parameters=parameters,
            timeout=600,
            max_attempts=5
        )
        
        assert target.target == "ssh://192.168.1.1:22"
        assert target.risk_level == RiskLevel.HIGH
        assert target.parameters == parameters
        assert target.timeout == 600
        assert target.max_attempts == 5


class TestExploitResult:
    """Test ExploitResult data class"""
    
    def test_exploit_result_creation(self):
        """Test ExploitResult creation"""
        timestamp = datetime.utcnow()
        duration = timedelta(seconds=30)
        evidence = {"login_successful": True, "credentials": "admin:password"}
        
        result = ExploitResult(
            target="192.168.1.1",
            technique=ExploitTechnique.SSH_BRUTEFORCE,
            timestamp=timestamp,
            duration=duration,
            status=ExploitStatus.SUCCESS,
            success=True,
            evidence=evidence,
            risk_score=8.5
        )
        
        assert result.target == "192.168.1.1"
        assert result.technique == ExploitTechnique.SSH_BRUTEFORCE
        assert result.timestamp == timestamp
        assert result.duration == duration
        assert result.status == ExploitStatus.SUCCESS
        assert result.success is True
        assert result.evidence == evidence
        assert result.risk_score == 8.5
        assert result.metadata == {}


class TestAuthorization:
    """Test Authorization data class"""
    
    def test_authorization_creation(self):
        """Test Authorization creation"""
        expires_at = datetime.utcnow() + timedelta(hours=24)
        
        auth = Authorization(
            target="192.168.1.1",
            scope=["reconnaissance", "scanning"],
            authorized_by="test-user",
            expires_at=expires_at,
            justification="Authorized penetration test"
        )
        
        assert auth.target == "192.168.1.1"
        assert auth.scope == ["reconnaissance", "scanning"]
        assert auth.authorized_by == "test-user"
        assert auth.expires_at == expires_at
        assert auth.justification == "Authorized penetration test"
        assert auth.metadata == {}
    
    def test_authorization_is_valid(self):
        """Test authorization validity check"""
        # Valid authorization
        valid_auth = Authorization(
            target="192.168.1.1",
            scope=["exploitation"],
            authorized_by="test-user",
            expires_at=datetime.utcnow() + timedelta(hours=1)
        )
        
        assert valid_auth.is_valid() is True
        
        # Expired authorization
        expired_auth = Authorization(
            target="192.168.1.1",
            scope=["exploitation"],
            authorized_by="test-user",
            expires_at=datetime.utcnow() - timedelta(hours=1)
        )
        
        assert expired_auth.is_valid() is False
    
    def test_authorization_has_scope(self):
        """Test authorization scope check"""
        auth = Authorization(
            target="192.168.1.1",
            scope=["reconnaissance", "scanning", "exploitation"],
            authorized_by="test-user",
            expires_at=datetime.utcnow() + timedelta(hours=1)
        )
        
        assert auth.has_scope("reconnaissance") is True
        assert auth.has_scope("exploitation") is True
        assert auth.has_scope("reporting") is False


class TestAuthorizationManager:
    """Test AuthorizationManager functionality"""
    
    @pytest.fixture
    def auth_manager(self):
        """Authorization manager fixture"""
        return AuthorizationManager()
    
    @pytest.mark.asyncio
    async def test_create_authorization(self, auth_manager):
        """Test authorization creation"""
        auth_request = {
            "target": "192.168.1.1",
            "scope": ["reconnaissance", "scanning"],
            "authorized_by": "test-user",
            "duration_hours": 24,
            "justification": "Authorized penetration test"
        }
        
        auth_token = await auth_manager.create_authorization(auth_request)
        
        assert auth_token is not None
        assert auth_token in auth_manager.authorizations
        
        auth = auth_manager.authorizations[auth_token]
        assert auth.target == "192.168.1.1"
        assert auth.scope == ["reconnaissance", "scanning"]
        assert auth.authorized_by == "test-user"
    
    @pytest.mark.asyncio
    async def test_validate_authorization_valid(self, auth_manager):
        """Test authorization validation - valid"""
        auth_request = {
            "target": "192.168.1.1",
            "scope": ["exploitation"],
            "authorized_by": "test-user",
            "duration_hours": 1,
            "justification": "Test authorization"
        }
        
        auth_token = await auth_manager.create_authorization(auth_request)
        
        is_valid = await auth_manager.validate_authorization(auth_token, "192.168.1.1", "exploitation")
        
        assert is_valid is True
    
    @pytest.mark.asyncio
    async def test_validate_authorization_invalid_token(self, auth_manager):
        """Test authorization validation - invalid token"""
        is_valid = await auth_manager.validate_authorization("invalid-token", "192.168.1.1", "exploitation")
        
        assert is_valid is False
    
    @pytest.mark.asyncio
    async def test_validate_authorization_wrong_target(self, auth_manager):
        """Test authorization validation - wrong target"""
        auth_request = {
            "target": "192.168.1.1",
            "scope": ["exploitation"],
            "authorized_by": "test-user",
            "duration_hours": 1,
            "justification": "Test authorization"
        }
        
        auth_token = await auth_manager.create_authorization(auth_request)
        
        is_valid = await auth_manager.validate_authorization(auth_token, "192.168.1.2", "exploitation")
        
        assert is_valid is False
    
    @pytest.mark.asyncio
    async def test_validate_authorization_wrong_scope(self, auth_manager):
        """Test authorization validation - wrong scope"""
        auth_request = {
            "target": "192.168.1.1",
            "scope": ["reconnaissance"],
            "authorized_by": "test-user",
            "duration_hours": 1,
            "justification": "Test authorization"
        }
        
        auth_token = await auth_manager.create_authorization(auth_request)
        
        is_valid = await auth_manager.validate_authorization(auth_token, "192.168.1.1", "exploitation")
        
        assert is_valid is False
    
    @pytest.mark.asyncio
    async def test_revoke_authorization(self, auth_manager):
        """Test authorization revocation"""
        auth_request = {
            "target": "192.168.1.1",
            "scope": ["exploitation"],
            "authorized_by": "test-user",
            "duration_hours": 1,
            "justification": "Test authorization"
        }
        
        auth_token = await auth_manager.create_authorization(auth_request)
        
        success = await auth_manager.revoke_authorization(auth_token)
        
        assert success is True
        assert auth_token not in auth_manager.authorizations
    
    @pytest.mark.asyncio
    async def test_list_authorizations(self, auth_manager):
        """Test listing authorizations"""
        auth_request = {
            "target": "192.168.1.1",
            "scope": ["exploitation"],
            "authorized_by": "test-user",
            "duration_hours": 1,
            "justification": "Test authorization"
        }
        
        auth_token = await auth_manager.create_authorization(auth_request)
        
        authorizations = await auth_manager.list_authorizations()
        
        assert len(authorizations) == 1
        assert auth_token in authorizations
    
    @pytest.mark.asyncio
    async def test_cleanup_expired_authorizations(self, auth_manager):
        """Test cleanup of expired authorizations"""
        # Create expired authorization
        auth_request = {
            "target": "192.168.1.1",
            "scope": ["exploitation"],
            "authorized_by": "test-user",
            "duration_hours": -1,  # Expired
            "justification": "Test authorization"
        }
        
        auth_token = await auth_manager.create_authorization(auth_request)
        
        # Manually expire the authorization
        auth_manager.authorizations[auth_token].expires_at = datetime.utcnow() - timedelta(hours=1)
        
        await auth_manager.cleanup_expired_authorizations()
        
        assert auth_token not in auth_manager.authorizations


class TestSafetyMonitor:
    """Test SafetyMonitor functionality"""
    
    @pytest.fixture
    def safety_monitor(self):
        """Safety monitor fixture"""
        return SafetyMonitor()
    
    @pytest.mark.asyncio
    async def test_assess_risk_level(self, safety_monitor):
        """Test risk level assessment"""
        # Low risk target
        low_risk_target = ExploitTarget(
            target="192.168.1.1",
            technique=ExploitTechnique.BANNER_GRABBING,
            category=ExploitCategory.INFORMATION_GATHERING
        )
        
        risk_level = await safety_monitor.assess_risk_level(low_risk_target)
        
        assert risk_level == RiskLevel.LOW
        
        # High risk target
        high_risk_target = ExploitTarget(
            target="192.168.1.1",
            technique=ExploitTechnique.BUFFER_OVERFLOW,
            category=ExploitCategory.SYSTEM_EXPLOITATION
        )
        
        risk_level = await safety_monitor.assess_risk_level(high_risk_target)
        
        assert risk_level == RiskLevel.HIGH
    
    @pytest.mark.asyncio
    async def test_check_target_safety(self, safety_monitor):
        """Test target safety check"""
        # Safe target
        safe_target = ExploitTarget(
            target="192.168.1.100",  # Test environment
            technique=ExploitTechnique.SSH_BRUTEFORCE,
            category=ExploitCategory.CREDENTIAL_ATTACK
        )
        
        is_safe = await safety_monitor.check_target_safety(safe_target)
        
        assert is_safe is True
        
        # Potentially unsafe target
        unsafe_target = ExploitTarget(
            target="8.8.8.8",  # Public DNS server
            technique=ExploitTechnique.DOS_ATTACK,
            category=ExploitCategory.DENIAL_OF_SERVICE
        )
        
        is_safe = await safety_monitor.check_target_safety(unsafe_target)
        
        assert is_safe is False
    
    @pytest.mark.asyncio
    async def test_monitor_exploit_execution(self, safety_monitor):
        """Test exploit execution monitoring"""
        target = ExploitTarget(
            target="192.168.1.1",
            technique=ExploitTechnique.SSH_BRUTEFORCE,
            category=ExploitCategory.CREDENTIAL_ATTACK
        )
        
        # Start monitoring
        await safety_monitor.start_monitoring(target)
        
        # Should be monitoring
        assert target.target in safety_monitor.active_monitors
        
        # Stop monitoring
        await safety_monitor.stop_monitoring(target)
        
        # Should not be monitoring
        assert target.target not in safety_monitor.active_monitors
    
    @pytest.mark.asyncio
    async def test_emergency_stop(self, safety_monitor):
        """Test emergency stop functionality"""
        target = ExploitTarget(
            target="192.168.1.1",
            technique=ExploitTechnique.SSH_BRUTEFORCE,
            category=ExploitCategory.CREDENTIAL_ATTACK
        )
        
        # Start monitoring
        await safety_monitor.start_monitoring(target)
        
        # Emergency stop
        success = await safety_monitor.emergency_stop(target, "Test emergency stop")
        
        assert success is True
        assert target.target not in safety_monitor.active_monitors
    
    @pytest.mark.asyncio
    async def test_get_safety_report(self, safety_monitor):
        """Test safety report generation"""
        target = ExploitTarget(
            target="192.168.1.1",
            technique=ExploitTechnique.SSH_BRUTEFORCE,
            category=ExploitCategory.CREDENTIAL_ATTACK
        )
        
        # Start monitoring
        await safety_monitor.start_monitoring(target)
        
        report = await safety_monitor.get_safety_report(target)
        
        assert report is not None
        assert report["target"] == "192.168.1.1"
        assert "risk_level" in report
        assert "monitoring_status" in report
        assert "safety_checks" in report


class TestExploitEngine:
    """Test ExploitEngine functionality"""
    
    @pytest.fixture
    def exploit_engine(self):
        """Exploit engine fixture"""
        return ExploitEngine()
    
    @pytest.mark.asyncio
    async def test_ssh_bruteforce_success(self, exploit_engine):
        """Test SSH bruteforce attack - success"""
        target = ExploitTarget(
            target="192.168.1.1",
            technique=ExploitTechnique.SSH_BRUTEFORCE,
            category=ExploitCategory.CREDENTIAL_ATTACK,
            parameters={
                "username": "admin",
                "password_list": ["admin", "password", "123456"]
            }
        )
        
        with patch('paramiko.SSHClient') as mock_ssh:
            mock_ssh_client = Mock()
            mock_ssh_client.connect.return_value = None  # Successful connection
            mock_ssh_client.close.return_value = None
            mock_ssh.return_value = mock_ssh_client
            
            result = await exploit_engine.execute_exploit(target)
            
            assert result.success is True
            assert result.status == ExploitStatus.SUCCESS
            assert result.technique == ExploitTechnique.SSH_BRUTEFORCE
            assert "credentials" in result.evidence
    
    @pytest.mark.asyncio
    async def test_ssh_bruteforce_failure(self, exploit_engine):
        """Test SSH bruteforce attack - failure"""
        target = ExploitTarget(
            target="192.168.1.1",
            technique=ExploitTechnique.SSH_BRUTEFORCE,
            category=ExploitCategory.CREDENTIAL_ATTACK,
            parameters={
                "username": "admin",
                "password_list": ["wrong1", "wrong2"]
            }
        )
        
        with patch('paramiko.SSHClient') as mock_ssh:
            mock_ssh_client = Mock()
            mock_ssh_client.connect.side_effect = Exception("Authentication failed")
            mock_ssh.return_value = mock_ssh_client
            
            result = await exploit_engine.execute_exploit(target)
            
            assert result.success is False
            assert result.status == ExploitStatus.FAILED
            assert result.technique == ExploitTechnique.SSH_BRUTEFORCE
    
    @pytest.mark.asyncio
    async def test_sql_injection_success(self, exploit_engine):
        """Test SQL injection attack - success"""
        target = ExploitTarget(
            target="http://192.168.1.1/login",
            technique=ExploitTechnique.SQL_INJECTION,
            category=ExploitCategory.WEB_APPLICATION,
            parameters={
                "parameter": "username",
                "payload": "' OR '1'='1"
            }
        )
        
        with patch('requests.post') as mock_post:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.text = "Welcome, admin!"
            mock_response.headers = {}
            mock_post.return_value = mock_response
            
            result = await exploit_engine.execute_exploit(target)
            
            assert result.success is True
            assert result.status == ExploitStatus.SUCCESS
            assert result.technique == ExploitTechnique.SQL_INJECTION
    
    @pytest.mark.asyncio
    async def test_xss_attack_success(self, exploit_engine):
        """Test XSS attack - success"""
        target = ExploitTarget(
            target="http://192.168.1.1/search",
            technique=ExploitTechnique.XSS_ATTACK,
            category=ExploitCategory.WEB_APPLICATION,
            parameters={
                "parameter": "query",
                "payload": "<script>alert('XSS')</script>"
            }
        )
        
        with patch('requests.get') as mock_get:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.text = "Results for: <script>alert('XSS')</script>"
            mock_response.headers = {}
            mock_get.return_value = mock_response
            
            result = await exploit_engine.execute_exploit(target)
            
            assert result.success is True
            assert result.status == ExploitStatus.SUCCESS
            assert result.technique == ExploitTechnique.XSS_ATTACK
    
    @pytest.mark.asyncio
    async def test_command_injection_success(self, exploit_engine):
        """Test command injection attack - success"""
        target = ExploitTarget(
            target="http://192.168.1.1/ping",
            technique=ExploitTechnique.COMMAND_INJECTION,
            category=ExploitCategory.WEB_APPLICATION,
            parameters={
                "parameter": "host",
                "payload": "127.0.0.1; whoami"
            }
        )
        
        with patch('requests.post') as mock_post:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.text = "PING 127.0.0.1\nroot"
            mock_response.headers = {}
            mock_post.return_value = mock_response
            
            result = await exploit_engine.execute_exploit(target)
            
            assert result.success is True
            assert result.status == ExploitStatus.SUCCESS
            assert result.technique == ExploitTechnique.COMMAND_INJECTION
    
    @pytest.mark.asyncio
    async def test_file_upload_vulnerability(self, exploit_engine):
        """Test file upload vulnerability exploitation"""
        target = ExploitTarget(
            target="http://192.168.1.1/upload",
            technique=ExploitTechnique.FILE_UPLOAD,
            category=ExploitCategory.WEB_APPLICATION,
            parameters={
                "filename": "shell.php",
                "content": "<?php system($_GET['cmd']); ?>"
            }
        )
        
        with patch('requests.post') as mock_post:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.text = "File uploaded successfully"
            mock_response.headers = {}
            mock_post.return_value = mock_response
            
            result = await exploit_engine.execute_exploit(target)
            
            assert result.success is True
            assert result.status == ExploitStatus.SUCCESS
            assert result.technique == ExploitTechnique.FILE_UPLOAD
    
    @pytest.mark.asyncio
    async def test_exploit_timeout(self, exploit_engine):
        """Test exploit timeout handling"""
        target = ExploitTarget(
            target="192.168.1.1",
            technique=ExploitTechnique.SSH_BRUTEFORCE,
            category=ExploitCategory.CREDENTIAL_ATTACK,
            timeout=1,  # Very short timeout
            parameters={
                "username": "admin",
                "password_list": ["admin"]
            }
        )
        
        with patch('paramiko.SSHClient') as mock_ssh:
            mock_ssh_client = Mock()
            mock_ssh_client.connect.side_effect = asyncio.TimeoutError()
            mock_ssh.return_value = mock_ssh_client
            
            result = await exploit_engine.execute_exploit(target)
            
            assert result.success is False
            assert result.status == ExploitStatus.TIMEOUT
    
    def test_get_available_techniques(self, exploit_engine):
        """Test getting available exploit techniques"""
        techniques = exploit_engine.get_available_techniques()
        
        assert isinstance(techniques, list)
        assert len(techniques) > 0
        assert all(isinstance(t, dict) for t in techniques)
        assert all("technique" in t for t in techniques)
        assert all("category" in t for t in techniques)
        assert all("risk_level" in t for t in techniques)
    
    def test_get_technique_info(self, exploit_engine):
        """Test getting technique information"""
        info = exploit_engine.get_technique_info(ExploitTechnique.SSH_BRUTEFORCE)
        
        assert info is not None
        assert info["technique"] == ExploitTechnique.SSH_BRUTEFORCE
        assert info["category"] == ExploitCategory.CREDENTIAL_ATTACK
        assert "description" in info
        assert "parameters" in info
        assert "risk_level" in info


class TestExploitationModule:
    """Test main exploitation module"""
    
    @pytest.fixture
    def config(self):
        """Configuration fixture"""
        return AetherVeilConfig()
    
    @pytest.fixture
    def exploitation_module(self, config):
        """Exploitation module fixture"""
        return ExploitationModule(config)
    
    @pytest.mark.asyncio
    async def test_module_initialization(self, exploitation_module):
        """Test module initialization"""
        assert exploitation_module.module_type.value == "exploitation"
        assert exploitation_module.status.value == "initialized"
        assert exploitation_module.version == "1.0.0"
        assert exploitation_module.exploit_engine is not None
        assert exploitation_module.auth_manager is not None
        assert exploitation_module.safety_monitor is not None
        assert len(exploitation_module.results) == 0
    
    @pytest.mark.asyncio
    async def test_module_start_stop(self, exploitation_module):
        """Test module start and stop"""
        # Test start
        success = await exploitation_module.start()
        assert success is True
        assert exploitation_module.status.value == "running"
        
        # Test stop
        success = await exploitation_module.stop()
        assert success is True
        assert exploitation_module.status.value == "stopped"
    
    @pytest.mark.asyncio
    async def test_create_authorization(self, exploitation_module):
        """Test authorization creation"""
        auth_request = {
            "target": "192.168.1.1",
            "scope": ["exploitation"],
            "authorized_by": "test-user",
            "duration_hours": 1,
            "justification": "Test authorization"
        }
        
        auth_token = await exploitation_module.create_authorization(auth_request)
        
        assert auth_token is not None
        assert auth_token in exploitation_module.auth_manager.authorizations
    
    @pytest.mark.asyncio
    async def test_execute_exploitation_with_authorization(self, exploitation_module):
        """Test exploitation execution with valid authorization"""
        # Create authorization
        auth_request = {
            "target": "192.168.1.1",
            "scope": ["exploitation"],
            "authorized_by": "test-user",
            "duration_hours": 1,
            "justification": "Test authorization"
        }
        
        auth_token = await exploitation_module.create_authorization(auth_request)
        
        # Create exploit target
        target = ExploitTarget(
            target="192.168.1.1",
            technique=ExploitTechnique.SSH_BRUTEFORCE,
            category=ExploitCategory.CREDENTIAL_ATTACK,
            parameters={
                "username": "admin",
                "password_list": ["admin"]
            }
        )
        
        # Mock exploit execution
        with patch.object(exploitation_module.exploit_engine, 'execute_exploit') as mock_execute:
            mock_result = ExploitResult(
                target="192.168.1.1",
                technique=ExploitTechnique.SSH_BRUTEFORCE,
                timestamp=datetime.utcnow(),
                duration=timedelta(seconds=30),
                status=ExploitStatus.SUCCESS,
                success=True,
                evidence={"credentials": "admin:admin"},
                risk_score=5.0
            )
            mock_execute.return_value = mock_result
            
            result = await exploitation_module.execute_exploitation(target, auth_token)
            
            assert result.success is True
            assert result.status == ExploitStatus.SUCCESS
            assert len(exploitation_module.results) == 1
    
    @pytest.mark.asyncio
    async def test_execute_exploitation_without_authorization(self, exploitation_module):
        """Test exploitation execution without authorization"""
        target = ExploitTarget(
            target="192.168.1.1",
            technique=ExploitTechnique.SSH_BRUTEFORCE,
            category=ExploitCategory.CREDENTIAL_ATTACK
        )
        
        with pytest.raises(Exception, match="Invalid authorization"):
            await exploitation_module.execute_exploitation(target, "invalid-token")
    
    @pytest.mark.asyncio
    async def test_execute_exploitation_unsafe_target(self, exploitation_module):
        """Test exploitation execution with unsafe target"""
        # Create authorization
        auth_request = {
            "target": "8.8.8.8",
            "scope": ["exploitation"],
            "authorized_by": "test-user",
            "duration_hours": 1,
            "justification": "Test authorization"
        }
        
        auth_token = await exploitation_module.create_authorization(auth_request)
        
        # Create unsafe target
        target = ExploitTarget(
            target="8.8.8.8",
            technique=ExploitTechnique.DOS_ATTACK,
            category=ExploitCategory.DENIAL_OF_SERVICE
        )
        
        # Mock safety check
        with patch.object(exploitation_module.safety_monitor, 'check_target_safety', return_value=False):
            with pytest.raises(Exception, match="Target safety check failed"):
                await exploitation_module.execute_exploitation(target, auth_token)
    
    @pytest.mark.asyncio
    async def test_bulk_exploitation(self, exploitation_module):
        """Test bulk exploitation"""
        # Create authorization
        auth_request = {
            "target": "192.168.1.0/24",
            "scope": ["exploitation"],
            "authorized_by": "test-user",
            "duration_hours": 1,
            "justification": "Test authorization"
        }
        
        auth_token = await exploitation_module.create_authorization(auth_request)
        
        targets = [
            ExploitTarget("192.168.1.1", ExploitTechnique.SSH_BRUTEFORCE, ExploitCategory.CREDENTIAL_ATTACK),
            ExploitTarget("192.168.1.2", ExploitTechnique.SSH_BRUTEFORCE, ExploitCategory.CREDENTIAL_ATTACK)
        ]
        
        # Mock execute_exploitation
        with patch.object(exploitation_module, 'execute_exploitation') as mock_execute:
            mock_result = ExploitResult(
                target="test",
                technique=ExploitTechnique.SSH_BRUTEFORCE,
                timestamp=datetime.utcnow(),
                duration=timedelta(seconds=30),
                status=ExploitStatus.SUCCESS,
                success=False,
                evidence={},
                risk_score=1.0
            )
            mock_execute.return_value = mock_result
            
            results = await exploitation_module.bulk_exploitation(targets, auth_token)
            
            assert len(results) == 2
            assert all(isinstance(r, ExploitResult) for r in results)
    
    @pytest.mark.asyncio
    async def test_emergency_stop(self, exploitation_module):
        """Test emergency stop functionality"""
        # Create authorization
        auth_request = {
            "target": "192.168.1.1",
            "scope": ["exploitation"],
            "authorized_by": "test-user",
            "duration_hours": 1,
            "justification": "Test authorization"
        }
        
        auth_token = await exploitation_module.create_authorization(auth_request)
        
        # Mock safety monitor
        with patch.object(exploitation_module.safety_monitor, 'emergency_stop', return_value=True):
            success = await exploitation_module.emergency_stop(auth_token, "Test emergency stop")
            
            assert success is True
    
    def test_get_results_filtering(self, exploitation_module):
        """Test result filtering"""
        # Add test results
        result1 = ExploitResult(
            target="192.168.1.1",
            technique=ExploitTechnique.SSH_BRUTEFORCE,
            timestamp=datetime.utcnow(),
            duration=timedelta(seconds=30),
            status=ExploitStatus.SUCCESS,
            success=True,
            evidence={},
            risk_score=5.0
        )
        
        result2 = ExploitResult(
            target="192.168.1.2",
            technique=ExploitTechnique.SQL_INJECTION,
            timestamp=datetime.utcnow(),
            duration=timedelta(seconds=45),
            status=ExploitStatus.FAILED,
            success=False,
            evidence={},
            risk_score=7.5
        )
        
        exploitation_module.results = [result1, result2]
        
        # Test filtering by target
        filtered = exploitation_module.get_results(target="192.168.1.1")
        assert len(filtered) == 1
        assert filtered[0].target == "192.168.1.1"
        
        # Test filtering by technique
        filtered = exploitation_module.get_results(technique=ExploitTechnique.SSH_BRUTEFORCE)
        assert len(filtered) == 1
        assert filtered[0].technique == ExploitTechnique.SSH_BRUTEFORCE
        
        # Test filtering by success
        filtered = exploitation_module.get_results(success=True)
        assert len(filtered) == 1
        assert filtered[0].success is True
    
    def test_export_results_json(self, exploitation_module):
        """Test JSON export of results"""
        result = ExploitResult(
            target="192.168.1.1",
            technique=ExploitTechnique.SSH_BRUTEFORCE,
            timestamp=datetime.utcnow(),
            duration=timedelta(seconds=30),
            status=ExploitStatus.SUCCESS,
            success=True,
            evidence={"credentials": "admin:admin"},
            risk_score=5.0
        )
        
        exploitation_module.results = [result]
        
        json_output = exploitation_module.export_results("json")
        
        assert json_output != ""
        # Verify it's valid JSON
        parsed = json.loads(json_output)
        assert len(parsed) == 1
        assert parsed[0]["target"] == "192.168.1.1"
        assert parsed[0]["technique"] == "ssh_bruteforce"
        assert parsed[0]["success"] is True
    
    @pytest.mark.asyncio
    async def test_get_status(self, exploitation_module):
        """Test module status reporting"""
        # Add test results
        result = ExploitResult(
            target="192.168.1.1",
            technique=ExploitTechnique.SSH_BRUTEFORCE,
            timestamp=datetime.utcnow(),
            duration=timedelta(seconds=30),
            status=ExploitStatus.SUCCESS,
            success=True,
            evidence={},
            risk_score=5.0
        )
        
        exploitation_module.results = [result]
        
        status = await exploitation_module.get_status()
        
        assert status["module"] == "exploitation"
        assert status["status"] == "initialized"
        assert status["version"] == "1.0.0"
        assert status["exploits_executed"] == 1
        assert status["successful_exploits"] == 1
        assert status["failed_exploits"] == 0
        assert status["active_authorizations"] == 0
    
    def test_get_available_techniques(self, exploitation_module):
        """Test getting available exploit techniques"""
        techniques = exploitation_module.get_available_techniques()
        
        assert isinstance(techniques, list)
        assert len(techniques) > 0
        assert all(isinstance(t, dict) for t in techniques)


@pytest.mark.performance
class TestExploitationPerformance:
    """Performance tests for exploitation module"""
    
    @pytest.fixture
    def config(self):
        """Configuration fixture"""
        return AetherVeilConfig()
    
    @pytest.fixture
    def exploitation_module(self, config):
        """Exploitation module fixture"""
        return ExploitationModule(config)
    
    @pytest.mark.asyncio
    async def test_bulk_exploitation_performance(self, exploitation_module, performance_monitor):
        """Test bulk exploitation performance"""
        # Create authorization
        auth_request = {
            "target": "192.168.1.0/24",
            "scope": ["exploitation"],
            "authorized_by": "test-user",
            "duration_hours": 1,
            "justification": "Test authorization"
        }
        
        auth_token = await exploitation_module.create_authorization(auth_request)
        
        # Create multiple targets
        targets = [
            ExploitTarget(f"192.168.1.{i}", ExploitTechnique.SSH_BRUTEFORCE, ExploitCategory.CREDENTIAL_ATTACK)
            for i in range(1, 11)
        ]
        
        # Mock execute_exploitation
        with patch.object(exploitation_module, 'execute_exploitation') as mock_execute:
            mock_result = ExploitResult(
                target="test",
                technique=ExploitTechnique.SSH_BRUTEFORCE,
                timestamp=datetime.utcnow(),
                duration=timedelta(seconds=1),
                status=ExploitStatus.FAILED,
                success=False,
                evidence={},
                risk_score=1.0
            )
            mock_execute.return_value = mock_result
            
            performance_monitor.start()
            
            results = await exploitation_module.bulk_exploitation(targets, auth_token)
            
            performance_monitor.stop()
            
            duration = performance_monitor.get_duration()
            assert duration is not None
            assert duration < 30.0  # Should complete within 30 seconds
            assert len(results) == 10


@pytest.mark.security
class TestExploitationSecurity:
    """Security tests for exploitation module"""
    
    @pytest.fixture
    def config(self):
        """Configuration fixture"""
        return AetherVeilConfig()
    
    @pytest.fixture
    def exploitation_module(self, config):
        """Exploitation module fixture"""
        return ExploitationModule(config)
    
    @pytest.mark.asyncio
    async def test_authorization_required(self, exploitation_module):
        """Test that authorization is required for exploitation"""
        target = ExploitTarget(
            target="192.168.1.1",
            technique=ExploitTechnique.SSH_BRUTEFORCE,
            category=ExploitCategory.CREDENTIAL_ATTACK
        )
        
        # Should fail without authorization
        with pytest.raises(Exception):
            await exploitation_module.execute_exploitation(target, "invalid-token")
    
    @pytest.mark.asyncio
    async def test_target_safety_checks(self, exploitation_module):
        """Test target safety checks"""
        # Create authorization for unsafe target
        auth_request = {
            "target": "8.8.8.8",
            "scope": ["exploitation"],
            "authorized_by": "test-user",
            "duration_hours": 1,
            "justification": "Test authorization"
        }
        
        auth_token = await exploitation_module.create_authorization(auth_request)
        
        # Create unsafe target
        target = ExploitTarget(
            target="8.8.8.8",
            technique=ExploitTechnique.DOS_ATTACK,
            category=ExploitCategory.DENIAL_OF_SERVICE
        )
        
        # Should fail safety check
        with patch.object(exploitation_module.safety_monitor, 'check_target_safety', return_value=False):
            with pytest.raises(Exception, match="Target safety check failed"):
                await exploitation_module.execute_exploitation(target, auth_token)
    
    @pytest.mark.asyncio
    async def test_input_validation(self, exploitation_module):
        """Test input validation"""
        # Test malicious targets
        malicious_targets = [
            "; rm -rf /",
            "../../..",
            "<script>alert('xss')</script>",
            "$(whoami)",
            "`id`"
        ]
        
        for target in malicious_targets:
            exploit_target = ExploitTarget(
                target=target,
                technique=ExploitTechnique.SSH_BRUTEFORCE,
                category=ExploitCategory.CREDENTIAL_ATTACK
            )
            
            # Should handle malicious input gracefully
            assert exploit_target.target == target
    
    @pytest.mark.asyncio
    async def test_authorization_expiration(self, exploitation_module):
        """Test authorization expiration"""
        # Create short-lived authorization
        auth_request = {
            "target": "192.168.1.1",
            "scope": ["exploitation"],
            "authorized_by": "test-user",
            "duration_hours": -1,  # Expired
            "justification": "Test authorization"
        }
        
        auth_token = await exploitation_module.create_authorization(auth_request)
        
        # Manually expire the authorization
        exploitation_module.auth_manager.authorizations[auth_token].expires_at = datetime.utcnow() - timedelta(hours=1)
        
        target = ExploitTarget(
            target="192.168.1.1",
            technique=ExploitTechnique.SSH_BRUTEFORCE,
            category=ExploitCategory.CREDENTIAL_ATTACK
        )
        
        # Should fail with expired authorization
        with pytest.raises(Exception):
            await exploitation_module.execute_exploitation(target, auth_token)
    
    @pytest.mark.asyncio
    async def test_scope_validation(self, exploitation_module):
        """Test authorization scope validation"""
        # Create authorization with limited scope
        auth_request = {
            "target": "192.168.1.1",
            "scope": ["reconnaissance"],  # No exploitation scope
            "authorized_by": "test-user",
            "duration_hours": 1,
            "justification": "Test authorization"
        }
        
        auth_token = await exploitation_module.create_authorization(auth_request)
        
        target = ExploitTarget(
            target="192.168.1.1",
            technique=ExploitTechnique.SSH_BRUTEFORCE,
            category=ExploitCategory.CREDENTIAL_ATTACK
        )
        
        # Should fail with insufficient scope
        with pytest.raises(Exception):
            await exploitation_module.execute_exploitation(target, auth_token)