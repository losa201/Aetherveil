#!/usr/bin/env python3
"""
Vulnerability Check Script for Container Images

This script analyzes Trivy vulnerability scan results and determines if container images
are safe for deployment based on vulnerability severity and policies.
"""

import json
import sys
import os
import glob
from typing import Dict, List, Any, Optional
import logging
from dataclasses import dataclass
from enum import Enum


class VulnerabilitySeverity(Enum):
    """Vulnerability severity levels"""
    UNKNOWN = "UNKNOWN"
    LOW = "LOW"
    MEDIUM = "MEDIUM"
    HIGH = "HIGH"
    CRITICAL = "CRITICAL"


@dataclass
class Vulnerability:
    """Represents a vulnerability finding"""
    vulnerability_id: str
    package_name: str
    severity: VulnerabilitySeverity
    description: str
    fixed_version: Optional[str] = None
    installed_version: Optional[str] = None
    cvss_score: Optional[float] = None
    cve_id: Optional[str] = None
    references: List[str] = None


class VulnerabilityChecker:
    """
    Vulnerability checker that analyzes container scan results
    """
    
    def __init__(self):
        self.vulnerabilities: List[Vulnerability] = []
        self.thresholds = {
            VulnerabilitySeverity.CRITICAL: 0,  # No critical vulnerabilities allowed
            VulnerabilitySeverity.HIGH: 3,      # Max 3 high severity vulnerabilities
            VulnerabilitySeverity.MEDIUM: 10,   # Max 10 medium severity vulnerabilities
            VulnerabilitySeverity.LOW: 50       # Max 50 low severity vulnerabilities
        }
        self.logger = logging.getLogger(__name__)
        
        # Configure logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
    
    def analyze_trivy_sarif(self, sarif_path: str) -> bool:
        """Analyze Trivy SARIF vulnerability scan results"""
        try:
            if not os.path.exists(sarif_path):
                self.logger.warning(f"Trivy SARIF report not found: {sarif_path}")
                return True
            
            with open(sarif_path, 'r') as f:
                sarif_data = json.load(f)
            
            runs = sarif_data.get('runs', [])
            for run in runs:
                results = run.get('results', [])
                for result in results:
                    rule_id = result.get('ruleId', 'unknown')
                    message = result.get('message', {}).get('text', 'No description')
                    
                    # Extract severity from rule metadata
                    severity = VulnerabilitySeverity.UNKNOWN
                    properties = result.get('properties', {})
                    if 'security-severity' in properties:
                        score = float(properties['security-severity'])
                        if score >= 9.0:
                            severity = VulnerabilitySeverity.CRITICAL
                        elif score >= 7.0:
                            severity = VulnerabilitySeverity.HIGH
                        elif score >= 4.0:
                            severity = VulnerabilitySeverity.MEDIUM
                        else:
                            severity = VulnerabilitySeverity.LOW
                    
                    # Extract location information
                    locations = result.get('locations', [])
                    package_name = 'unknown'
                    if locations:
                        logical_location = locations[0].get('logicalLocations', [{}])[0]
                        package_name = logical_location.get('name', 'unknown')
                    
                    vulnerability = Vulnerability(
                        vulnerability_id=rule_id,
                        package_name=package_name,
                        severity=severity,
                        description=message,
                        cvss_score=properties.get('security-severity'),
                        cve_id=rule_id if rule_id.startswith('CVE-') else None
                    )
                    self.vulnerabilities.append(vulnerability)
            
            self.logger.info(f"Analyzed {len(self.vulnerabilities)} vulnerabilities from {sarif_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error analyzing Trivy SARIF report: {e}")
            return False
    
    def analyze_trivy_json(self, json_path: str) -> bool:
        """Analyze Trivy JSON vulnerability scan results"""
        try:
            if not os.path.exists(json_path):
                self.logger.warning(f"Trivy JSON report not found: {json_path}")
                return True
            
            with open(json_path, 'r') as f:
                report_data = json.load(f)
            
            results = report_data.get('Results', [])
            for result in results:
                vulnerabilities = result.get('Vulnerabilities', [])
                for vuln in vulnerabilities:
                    severity_str = vuln.get('Severity', 'UNKNOWN')
                    try:
                        severity = VulnerabilitySeverity(severity_str)
                    except ValueError:
                        severity = VulnerabilitySeverity.UNKNOWN
                    
                    vulnerability = Vulnerability(
                        vulnerability_id=vuln.get('VulnerabilityID', 'unknown'),
                        package_name=vuln.get('PkgName', 'unknown'),
                        severity=severity,
                        description=vuln.get('Title', 'No description'),
                        fixed_version=vuln.get('FixedVersion'),
                        installed_version=vuln.get('InstalledVersion'),
                        cvss_score=self._extract_cvss_score(vuln),
                        cve_id=vuln.get('VulnerabilityID'),
                        references=vuln.get('References', [])
                    )
                    self.vulnerabilities.append(vulnerability)
            
            self.logger.info(f"Analyzed {len(self.vulnerabilities)} vulnerabilities from {json_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error analyzing Trivy JSON report: {e}")
            return False
    
    def _extract_cvss_score(self, vuln_data: Dict[str, Any]) -> Optional[float]:
        """Extract CVSS score from vulnerability data"""
        cvss = vuln_data.get('CVSS', {})
        
        # Try different CVSS versions
        for version in ['nvd', 'redhat', 'ubuntu']:
            if version in cvss:
                v3_score = cvss[version].get('V3Score')
                if v3_score:
                    return float(v3_score)
                
                v2_score = cvss[version].get('V2Score')
                if v2_score:
                    return float(v2_score)
        
        return None
    
    def get_severity_counts(self) -> Dict[VulnerabilitySeverity, int]:
        """Get count of vulnerabilities by severity level"""
        counts = {severity: 0 for severity in VulnerabilitySeverity}
        
        for vuln in self.vulnerabilities:
            counts[vuln.severity] += 1
        
        return counts
    
    def check_thresholds(self) -> bool:
        """Check if vulnerabilities exceed defined thresholds"""
        counts = self.get_severity_counts()
        
        for severity, count in counts.items():
            threshold = self.thresholds.get(severity, float('inf'))
            if count > threshold:
                self.logger.error(
                    f"Vulnerability threshold exceeded for {severity.value}: {count} > {threshold}"
                )
                return False
        
        return True
    
    def apply_vulnerability_exceptions(self):
        """Apply exceptions for known false positives or accepted risks"""
        exceptions = [
            # Example: Accept specific CVEs in development images
            {
                'vulnerability_id': 'CVE-2023-12345',
                'package_name': 'dev-tool',
                'reason': 'Development-only dependency'
            },
            # Example: Accept low severity vulnerabilities in base OS
            {
                'severity': VulnerabilitySeverity.LOW,
                'package_name_pattern': 'base-files',
                'reason': 'Base OS package with low risk'
            }
        ]
        
        original_count = len(self.vulnerabilities)
        filtered_vulnerabilities = []
        
        for vuln in self.vulnerabilities:
            should_exclude = False
            
            for exception in exceptions:
                if self._matches_exception(vuln, exception):
                    should_exclude = True
                    self.logger.info(
                        f"Excluded vulnerability {vuln.vulnerability_id} "
                        f"in {vuln.package_name}: {exception['reason']}"
                    )
                    break
            
            if not should_exclude:
                filtered_vulnerabilities.append(vuln)
        
        self.vulnerabilities = filtered_vulnerabilities
        excluded_count = original_count - len(self.vulnerabilities)
        
        if excluded_count > 0:
            self.logger.info(f"Applied exceptions: excluded {excluded_count} vulnerabilities")
    
    def _matches_exception(self, vuln: Vulnerability, exception: Dict[str, Any]) -> bool:
        """Check if vulnerability matches an exception rule"""
        # Check vulnerability ID
        if 'vulnerability_id' in exception:
            if vuln.vulnerability_id != exception['vulnerability_id']:
                return False
        
        # Check package name
        if 'package_name' in exception:
            if vuln.package_name != exception['package_name']:
                return False
        
        # Check package name pattern
        if 'package_name_pattern' in exception:
            if exception['package_name_pattern'] not in vuln.package_name:
                return False
        
        # Check severity
        if 'severity' in exception:
            if vuln.severity != exception['severity']:
                return False
        
        return True
    
    def get_fixable_vulnerabilities(self) -> List[Vulnerability]:
        """Get list of vulnerabilities that have fixes available"""
        return [v for v in self.vulnerabilities if v.fixed_version]
    
    def generate_report(self) -> str:
        """Generate a vulnerability report summary"""
        counts = self.get_severity_counts()
        fixable = self.get_fixable_vulnerabilities()
        
        report = [
            "Container Vulnerability Analysis Report",
            "=" * 45,
            f"Total vulnerabilities: {len(self.vulnerabilities)}",
            f"Fixable vulnerabilities: {len(fixable)}",
            ""
        ]
        
        for severity in VulnerabilitySeverity:
            count = counts[severity]
            threshold = self.thresholds.get(severity, float('inf'))
            if threshold == float('inf'):
                status = "N/A"
            else:
                status = "PASS" if count <= threshold else "FAIL"
            report.append(f"{severity.value}: {count}/{threshold} [{status}]")
        
        # Package breakdown
        package_counts = {}
        for vuln in self.vulnerabilities:
            package_counts[vuln.package_name] = package_counts.get(vuln.package_name, 0) + 1
        
        if package_counts:
            report.extend(["", "Top vulnerable packages:"])
            sorted_packages = sorted(package_counts.items(), key=lambda x: x[1], reverse=True)
            for package, count in sorted_packages[:10]:
                report.append(f"  {package}: {count}")
        
        # Critical and High severity vulnerabilities
        critical_high = [
            v for v in self.vulnerabilities 
            if v.severity in [VulnerabilitySeverity.CRITICAL, VulnerabilitySeverity.HIGH]
        ]
        
        if critical_high:
            report.extend(["", "Critical and High severity vulnerabilities:"])
            for vuln in critical_high[:20]:  # Show first 20
                fix_info = f" (Fix: {vuln.fixed_version})" if vuln.fixed_version else " (No fix)"
                report.append(
                    f"  [{vuln.severity.value}] {vuln.vulnerability_id}: "
                    f"{vuln.package_name} {vuln.installed_version}{fix_info}"
                )
            
            if len(critical_high) > 20:
                report.append(f"  ... and {len(critical_high) - 20} more")
        
        # Fixable vulnerabilities summary
        if fixable:
            report.extend(["", "Fixable vulnerabilities by severity:"])
            fixable_counts = {}
            for vuln in fixable:
                fixable_counts[vuln.severity] = fixable_counts.get(vuln.severity, 0) + 1
            
            for severity, count in fixable_counts.items():
                report.append(f"  {severity.value}: {count}")
        
        return "\n".join(report)
    
    def generate_remediation_advice(self) -> str:
        """Generate remediation advice for vulnerabilities"""
        fixable = self.get_fixable_vulnerabilities()
        
        if not fixable:
            return "No fixable vulnerabilities found."
        
        advice = ["Remediation Advice:", "=" * 20]
        
        # Group by package
        package_fixes = {}
        for vuln in fixable:
            if vuln.package_name not in package_fixes:
                package_fixes[vuln.package_name] = []
            package_fixes[vuln.package_name].append(vuln)
        
        for package, vulns in package_fixes.items():
            highest_severity = max(vulns, key=lambda v: self._severity_priority(v.severity))
            fixed_version = highest_severity.fixed_version
            
            advice.append(f"Package: {package}")
            advice.append(f"  Current version: {highest_severity.installed_version}")
            advice.append(f"  Fixed version: {fixed_version}")
            advice.append(f"  Vulnerabilities fixed: {len(vulns)}")
            advice.append(f"  Highest severity: {highest_severity.severity.value}")
            advice.append("")
        
        return "\n".join(advice)
    
    def _severity_priority(self, severity: VulnerabilitySeverity) -> int:
        """Get numeric priority for severity level"""
        priority_map = {
            VulnerabilitySeverity.CRITICAL: 4,
            VulnerabilitySeverity.HIGH: 3,
            VulnerabilitySeverity.MEDIUM: 2,
            VulnerabilitySeverity.LOW: 1,
            VulnerabilitySeverity.UNKNOWN: 0
        }
        return priority_map.get(severity, 0)
    
    def run(self, file_patterns: List[str]) -> bool:
        """Run the vulnerability check analysis"""
        success = True
        
        # Find all matching files
        all_files = []
        for pattern in file_patterns:
            all_files.extend(glob.glob(pattern))
        
        if not all_files:
            self.logger.warning("No vulnerability scan files found")
            return True
        
        # Analyze all files
        for file_path in all_files:
            self.logger.info(f"Analyzing vulnerability report: {file_path}")
            
            if file_path.endswith('.sarif'):
                if not self.analyze_trivy_sarif(file_path):
                    success = False
            elif file_path.endswith('.json'):
                if not self.analyze_trivy_json(file_path):
                    success = False
            else:
                self.logger.warning(f"Unsupported file format: {file_path}")
        
        # Apply exceptions
        self.apply_vulnerability_exceptions()
        
        # Generate and print report
        report = self.generate_report()
        print(report)
        
        # Generate remediation advice
        remediation = self.generate_remediation_advice()
        print(f"\n{remediation}")
        
        # Check thresholds
        if not self.check_thresholds():
            success = False
        
        # Write detailed report to file
        with open('vulnerability-check-report.txt', 'w') as f:
            f.write(report)
            f.write(f"\n\n{remediation}")
        
        return success


def main():
    """Main entry point"""
    if len(sys.argv) < 2:
        print("Usage: python vulnerability_check.py <file_pattern> [file_pattern...]")
        sys.exit(1)
    
    file_patterns = sys.argv[1:]
    checker = VulnerabilityChecker()
    
    if checker.run(file_patterns):
        print("\n✅ Vulnerability check PASSED")
        sys.exit(0)
    else:
        print("\n❌ Vulnerability check FAILED")
        sys.exit(1)


if __name__ == "__main__":
    main()